descriptions:
- lang: en
  value: 'In the Linux kernel, the following vulnerability has been resolved:


    drm: Don''t unref the same fb many times by mistake due to deadlock handling


    If we get a deadlock after the fb lookup in drm_mode_page_flip_ioctl()

    we proceed to unref the fb and then retry the whole thing from the top.

    But we forget to reset the fb pointer back to NULL, and so if we then

    get another error during the retry, before the fb lookup, we proceed

    the unref the same fb again without having gotten another reference.

    The end result is that the fb will (eventually) end up being freed

    while it''s still in use.


    Reset fb to NULL once we''ve unreffed it to avoid doing it again

    until we''ve done another fb lookup.


    This turned out to be pretty easy to hit on a DG2 when doing async

    flips (and CONFIG_DEBUG_WW_MUTEX_SLOWPATH=y). The first symptom I

    saw that drm_closefb() simply got stuck in a busy loop while walking

    the framebuffer list. Fortunately I was able to convince it to oops

    instead, and from there it was easier to track down the culprit.'
- lang: es
  value: "En el kernel de Linux se ha resuelto la siguiente vulnerabilidad: drm: No\
    \ desreferenciar el mismo fb muchas veces por error debido al manejo de interbloqueos\
    \ Si obtenemos un punto muerto despu\xE9s de la b\xFAsqueda de fb en drm_mode_page_flip_ioctl()\
    \ procedemos a desreferenciar el fb y luego Vuelva a intentarlo todo desde arriba.\
    \ Pero nos olvidamos de restablecer el puntero fb a NULL, por lo que si obtenemos\
    \ otro error durante el reintento, antes de la b\xFAsqueda de fb, procedemos a\
    \ desref el mismo fb nuevamente sin haber obtenido otra referencia. El resultado\
    \ final es que el Facebook (eventualmente) terminar\xE1 siendo liberado mientras\
    \ todav\xEDa est\xE1 en uso. Restablezca fb a NULL una vez que lo hayamos eliminado\
    \ para evitar hacerlo nuevamente hasta que hayamos realizado otra b\xFAsqueda\
    \ de fb. Esto result\xF3 ser bastante f\xE1cil de lograr en un DG2 cuando se realizan\
    \ volteos as\xEDncronos (y CONFIG_DEBUG_WW_MUTEX_SLOWPATH=y). El primer s\xED\
    ntoma que vi fue que drm_closefb() simplemente se qued\xF3 atascado en un bucle\
    \ ocupado mientras recorr\xEDa la lista de framebuffer. Afortunadamente, pude\
    \ convencerlo de que lo hiciera, y a partir de ah\xED fue m\xE1s f\xE1cil localizar\
    \ al culpable."
id: CVE-2023-52486
lastModified: '2024-03-12T12:40:13.500'
metrics: {}
published: '2024-03-11T18:15:16.427'
references:
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/376e21a9e4c2c63ee5d8d3aa74be5082c3882229
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/62f2e79cf9f4f47cc9dea9cebdf58d9f7b5695e0
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/9dd334a8245011ace45e53298175c7b659edb3e7
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/b4af63da9d94986c529d74499fdfe44289acd551
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/bfd0feb1b109cb63b87fdcd00122603787c75a1a
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/cb4daf271302d71a6b9a7c01bd0b6d76febd8f0c
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/d7afdf360f4ac142832b098b4de974e867cc063c
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/f55261469be87c55df13db76dc945f6bcd825105
sourceIdentifier: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
vulnStatus: Awaiting Analysis
