cveTags: []
descriptions:
- lang: en
  value: 'In the Linux kernel, the following vulnerability has been resolved:


    nfsd: fix handling of cached open files in nfsd4_open codepath


    Commit fb70bf124b05 ("NFSD: Instantiate a struct file when creating a

    regular NFSv4 file") added the ability to cache an open fd over a

    compound. There are a couple of problems with the way this currently

    works:


    It''s racy, as a newly-created nfsd_file can end up with its PENDING bit

    cleared while the nf is hashed, and the nf_file pointer is still zeroed

    out. Other tasks can find it in this state and they expect to see a

    valid nf_file, and can oops if nf_file is NULL.


    Also, there is no guarantee that we''ll end up creating a new nfsd_file

    if one is already in the hash. If an extant entry is in the hash with a

    valid nf_file, nfs4_get_vfs_file will clobber its nf_file pointer with

    the value of op_file and the old nf_file will leak.


    Fix both issues by making a new nfsd_file_acquirei_opened variant that

    takes an optional file pointer. If one is present when this is called,

    we''ll take a new reference to it instead of trying to open the file. If

    the nfsd_file already has a valid nf_file, we''ll just ignore the

    optional file and pass the nfsd_file back as-is.


    Also rework the tracepoints a bit to allow for an "opened" variant and

    don''t try to avoid counting acquisitions in the case where we already

    have a cached open file.'
- lang: es
  value: "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: nfsd:\
    \ corrige el manejo de archivos abiertos almacenados en cach\xE9 en la ruta de\
    \ c\xF3digo nfsd4_open el commit fb70bf124b05 (\"NFSD: crear una instancia de\
    \ un archivo de estructura al crear un archivo NFSv4 normal\") agreg\xF3 la capacidad\
    \ de almacenar en cach\xE9 un fd abierto sobre un compuesto. Hay un par de problemas\
    \ con la forma en que esto funciona actualmente: Es picante, ya que un nfsd_file\
    \ reci\xE9n creado puede terminar con su bit PENDIENTE borrado mientras el nf\
    \ tiene hash, y el puntero nf_file todav\xEDa est\xE1 puesto a cero. Otras tareas\
    \ pueden encontrarlo en este estado y esperan ver un nf_file v\xE1lido, y pueden\
    \ ir si nf_file es NULL. Adem\xE1s, no hay garant\xEDa de que terminemos creando\
    \ un nuevo nfsd_file si ya hay uno en el hash. Si una entrada existente est\xE1\
    \ en el hash con un nf_file v\xE1lido, nfs4_get_vfs_file golpear\xE1 su puntero\
    \ nf_file con el valor de op_file y el antiguo nf_file se filtrar\xE1. Solucione\
    \ ambos problemas creando una nueva variante nfsd_file_acquirei_opened que toma\
    \ un puntero de archivo opcional. Si hay uno presente cuando se llama, tomaremos\
    \ una nueva referencia en lugar de intentar abrir el archivo. Si el nfsd_file\
    \ ya tiene un nf_file v\xE1lido, simplemente ignoraremos el archivo opcional y\
    \ devolveremos el nfsd_file tal como est\xE1. Tambi\xE9n vuelva a trabajar un\
    \ poco los puntos de seguimiento para permitir una variante \"abierta\" y no intente\
    \ evitar contar adquisiciones en el caso de que ya tengamos un archivo abierto\
    \ en cach\xE9."
id: CVE-2023-52909
lastModified: '2024-08-21T12:30:33.697'
metrics: {}
published: '2024-08-21T07:15:06.857'
references:
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/0b3a551fa58b4da941efeb209b3770868e2eddd7
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/0b778361998d6c6356b8d2fc7ddf025fb3224654
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/45c08a752982116f3287afcd1bd9c50f4fab0c28
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/973acfdfe90c8a4e58ade97ff0653a498531ff2e
sourceIdentifier: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
vulnStatus: Undergoing Analysis
