cveTags: []
descriptions:
- lang: en
  value: 'In the Linux kernel, the following vulnerability has been resolved:


    tls: fix NULL deref on tls_sw_splice_eof() with empty record


    syzkaller discovered that if tls_sw_splice_eof() is executed as part of

    sendfile() when the plaintext/ciphertext sk_msg are empty, the send path

    gets confused because the empty ciphertext buffer does not have enough

    space for the encryption overhead. This causes tls_push_record() to go on

    the `split = true` path (which is only supposed to be used when interacting

    with an attached BPF program), and then get further confused and hit the

    tls_merge_open_record() path, which then assumes that there must be at

    least one populated buffer element, leading to a NULL deref.


    It is possible to have empty plaintext/ciphertext buffers if we previously

    bailed from tls_sw_sendmsg_locked() via the tls_trim_both_msgs() path.

    tls_sw_push_pending_record() already handles this case correctly; let''s do

    the same check in tls_sw_splice_eof().'
- lang: es
  value: "En el kernel de Linux, se resolvi\xF3 la siguiente vulnerabilidad: tls:\
    \ corrige NULL deref en tls_sw_splice_eof() con registro vac\xEDo syzkaller descubri\xF3\
    \ que si tls_sw_splice_eof() se ejecuta como parte de sendfile() cuando el texto\
    \ plano/texto cifrado sk_msg est\xE1 vac\xEDo, el env\xEDo La ruta se confunde\
    \ porque el b\xFAfer de texto cifrado vac\xEDo no tiene suficiente espacio para\
    \ la sobrecarga de cifrado. Esto hace que tls_push_record() vaya a la ruta `split\
    \ = true` (que se supone que solo debe usarse al interactuar con un programa BPF\
    \ adjunto), y luego se confunda a\xFAn m\xE1s y acceda a la ruta tls_merge_open_record(),\
    \ que luego supone que hay debe haber al menos un elemento de b\xFAfer poblado,\
    \ lo que lleva a una deref NULL. Es posible tener buffers de texto plano/texto\
    \ cifrado vac\xEDos si previamente salimos de tls_sw_sendmsg_locked() a trav\xE9\
    s de la ruta tls_trim_both_msgs(). tls_sw_push_pending_record() ya maneja este\
    \ caso correctamente; hagamos la misma verificaci\xF3n en tls_sw_splice_eof()."
id: CVE-2023-52767
lastModified: '2024-05-21T16:53:56.550'
metrics: {}
published: '2024-05-21T16:15:15.917'
references:
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/2214e2bb5489145aba944874d0ee1652a0a63dc8
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/53f2cb491b500897a619ff6abd72f565933760f0
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/944900fe2736c07288efe2d9394db4d3ca23f2c9
sourceIdentifier: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
vulnStatus: Awaiting Analysis
