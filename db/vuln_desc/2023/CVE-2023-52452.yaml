descriptions:
- lang: en
  value: 'In the Linux kernel, the following vulnerability has been resolved:


    bpf: Fix accesses to uninit stack slots


    Privileged programs are supposed to be able to read uninitialized stack

    memory (ever since 6715df8d5) but, before this patch, these accesses

    were permitted inconsistently. In particular, accesses were permitted

    above state->allocated_stack, but not below it. In other words, if the

    stack was already "large enough", the access was permitted, but

    otherwise the access was rejected instead of being allowed to "grow the

    stack". This undesired rejection was happening in two places:

    - in check_stack_slot_within_bounds()

    - in check_stack_range_initialized()

    This patch arranges for these accesses to be permitted. A bunch of tests

    that were relying on the old rejection had to change; all of them were

    changed to add also run unprivileged, in which case the old behavior

    persists. One tests couldn''t be updated - global_func16 - because it

    can''t run unprivileged for other reasons.


    This patch also fixes the tracking of the stack size for variable-offset

    reads. This second fix is bundled in the same commit as the first one

    because they''re inter-related. Before this patch, writes to the stack

    using registers containing a variable offset (as opposed to registers

    with fixed, known values) were not properly contributing to the

    function''s needed stack size. As a result, it was possible for a program

    to verify, but then to attempt to read out-of-bounds data at runtime

    because a too small stack had been allocated for it.


    Each function tracks the size of the stack it needs in

    bpf_subprog_info.stack_depth, which is maintained by

    update_stack_depth(). For regular memory accesses, check_mem_access()

    was calling update_state_depth() but it was passing in only the fixed

    part of the offset register, ignoring the variable offset. This was

    incorrect; the minimum possible value of that register should be used

    instead.


    This tracking is now fixed by centralizing the tracking of stack size in

    grow_stack_state(), and by lifting the calls to grow_stack_state() to

    check_stack_access_within_bounds() as suggested by Andrii. The code is

    now simpler and more convincingly tracks the correct maximum stack size.

    check_stack_range_initialized() can now rely on enough stack having been

    allocated for the access; this helps with the fix for the first issue.


    A few tests were changed to also check the stack depth computation. The

    one that fails without this patch is verifier_var_off:stack_write_priv_vs_unpriv.'
- lang: es
  value: "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: bpf:\
    \ corrige los accesos a las ranuras de la pila uninit. Se supone que los programas\
    \ privilegiados pueden leer la memoria de la pila no inicializada (desde 6715df8d5)\
    \ pero, antes de este parche, estos accesos se permit\xEDan de forma inconsistente.\
    \ En particular, se permit\xEDan accesos por encima de state-&gt;allocated_stack,\
    \ pero no por debajo de \xE9l. En otras palabras, si la pila ya era \"lo suficientemente\
    \ grande\", se permit\xEDa el acceso, pero en caso contrario se rechazaba el acceso\
    \ en lugar de permitir \"hacer crecer la pila\". Este rechazo no deseado ocurr\xED\
    a en dos lugares: - en check_stack_slot_within_bounds() - en check_stack_range_initialized()\
    \ Este parche dispone que estos accesos sean permitidos. Un mont\xF3n de pruebas\
    \ que depend\xEDan del antiguo rechazo tuvieron que cambiar; todos ellos se cambiaron\
    \ para agregar que tambi\xE9n se ejecutan sin privilegios, en cuyo caso el comportamiento\
    \ anterior persiste. Una prueba no se pudo actualizar (global_func16) porque no\
    \ se puede ejecutar sin privilegios por otros motivos. Este parche tambi\xE9n\
    \ corrige el seguimiento del tama\xF1o de la pila para lecturas con desplazamiento\
    \ variable. Esta segunda soluci\xF3n se incluye en la misma confirmaci\xF3n que\
    \ la primera porque est\xE1n interrelacionadas. Antes de este parche, las escrituras\
    \ en la pila usando registros que conten\xEDan un desplazamiento variable (a diferencia\
    \ de registros con valores fijos y conocidos) no contribu\xEDan adecuadamente\
    \ al tama\xF1o de pila necesario de la funci\xF3n. Como resultado, era posible\
    \ que un programa verificara, pero luego intentara leer datos fuera de l\xEDmites\
    \ en tiempo de ejecuci\xF3n porque se le hab\xEDa asignado una pila demasiado\
    \ peque\xF1a. Cada funci\xF3n rastrea el tama\xF1o de la pila que necesita en\
    \ bpf_subprog_info.stack_ Depth, que es mantenido por update_stack_ Depth(). Para\
    \ accesos regulares a la memoria, check_mem_access() estaba llamando a update_state_\
    \ Depth() pero pasaba solo la parte fija del registro de compensaci\xF3n, ignorando\
    \ la variable compensaci\xF3n. Esto era incorrecto; en su lugar se debe utilizar\
    \ el valor m\xEDnimo posible de ese registro. Este seguimiento ahora se soluciona\
    \ centralizando el seguimiento del tama\xF1o de la pila en grow_stack_state()\
    \ y elevando las llamadas a grow_stack_state() a check_stack_access_within_bounds()\
    \ como lo sugiere Andrii. El c\xF3digo ahora es m\xE1s simple y rastrea de manera\
    \ m\xE1s convincente el tama\xF1o m\xE1ximo de pila correcto. check_stack_range_initialized()\
    \ ahora puede confiar en que se haya asignado suficiente pila para el acceso;\
    \ esto ayuda con la soluci\xF3n del primer problema. Se cambiaron algunas pruebas\
    \ para verificar tambi\xE9n el c\xE1lculo de la profundidad de la pila. El que\
    \ falla sin este parche es verifier_var_off:stack_write_priv_vs_unpriv."
id: CVE-2023-52452
lastModified: '2024-02-22T19:07:27.197'
metrics: {}
published: '2024-02-22T17:15:08.830'
references:
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/0954982db8283016bf38e9db2da5adf47a102e19
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/6b4a64bafd107e521c01eec3453ce94a3fb38529
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/fbcf372c8eda2290470268e0afb5ab5d5f5d5fde
sourceIdentifier: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
vulnStatus: Awaiting Analysis
