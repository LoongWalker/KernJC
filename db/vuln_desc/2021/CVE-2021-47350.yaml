descriptions:
- lang: en
  value: 'In the Linux kernel, the following vulnerability has been resolved:


    powerpc/mm: Fix lockup on kernel exec fault


    The powerpc kernel is not prepared to handle exec faults from kernel.

    Especially, the function is_exec_fault() will return ''false'' when an

    exec fault is taken by kernel, because the check is based on reading

    current->thread.regs->trap which contains the trap from user.


    For instance, when provoking a LKDTM EXEC_USERSPACE test,

    current->thread.regs->trap is set to SYSCALL trap (0xc00), and

    the fault taken by the kernel is not seen as an exec fault by

    set_access_flags_filter().


    Commit d7df2443cd5f ("powerpc/mm: Fix spurious segfaults on radix

    with autonuma") made it clear and handled it properly. But later on

    commit d3ca587404b3 ("powerpc/mm: Fix reporting of kernel execute

    faults") removed that handling, introducing test based on error_code.

    And here is the problem, because on the 603 all upper bits of SRR1

    get cleared when the TLB instruction miss handler bails out to ISI.


    Until commit cbd7e6ca0210 ("powerpc/fault: Avoid heavy

    search_exception_tables() verification"), an exec fault from kernel

    at a userspace address was indirectly caught by the lack of entry for

    that address in the exception tables. But after that commit the

    kernel mainly relies on KUAP or on core mm handling to catch wrong

    user accesses. Here the access is not wrong, so mm handles it.

    It is a minor fault because PAGE_EXEC is not set,

    set_access_flags_filter() should set PAGE_EXEC and voila.

    But as is_exec_fault() returns false as explained in the beginning,

    set_access_flags_filter() bails out without setting PAGE_EXEC flag,

    which leads to a forever minor exec fault.


    As the kernel is not prepared to handle such exec faults, the thing to

    do is to fire in bad_kernel_fault() for any exec fault taken by the

    kernel, as it was prior to commit d3ca587404b3.'
- lang: es
  value: "En el kernel de Linux, se resolvi\xF3 la siguiente vulnerabilidad: powerpc/mm:\
    \ corrige el bloqueo en el fallo de ejecuci\xF3n del kernel. El kernel de powerpc\
    \ no est\xE1 preparado para manejar fallos de ejecuci\xF3n del kernel. Especialmente,\
    \ la funci\xF3n is_exec_fault() devolver\xE1 'false' cuando el kernel tome un\
    \ fallo de ejecuci\xF3n, porque la verificaci\xF3n se basa en la lectura de current-&gt;thread.regs-&gt;trap\
    \ que contiene la trampa del usuario. Por ejemplo, al provocar una prueba LKDTM\
    \ EXEC_USERSPACE, current-&gt;thread.regs-&gt;trap se establece en SYSCALL trap\
    \ (0xc00), y set_access_flags_filter() no ve el error cometido por el kernel como\
    \ un error de ejecuci\xF3n. La confirmaci\xF3n d7df2443cd5f (\"powerpc/mm: corregir\
    \ errores de segmentaci\xF3n falsos en radix con autonuma\") lo dej\xF3 claro\
    \ y lo manej\xF3 correctamente. Pero m\xE1s tarde, la confirmaci\xF3n d3ca587404b3\
    \ (\"powerpc/mm: corregir informes de fallas de ejecuci\xF3n del kernel\") elimin\xF3\
    \ ese manejo, introduciendo una prueba basada en error_code. Y aqu\xED est\xE1\
    \ el problema, porque en el 603 todos los bits superiores de SRR1 se borran cuando\
    \ el controlador de errores de instrucci\xF3n TLB sale a ISI. Hasta la confirmaci\xF3\
    n cbd7e6ca0210 (\"powerpc/fault: Evite la verificaci\xF3n pesada de search_exception_tables()\"\
    ), un fallo de ejecuci\xF3n del kernel en una direcci\xF3n de espacio de usuario\
    \ se detectaba indirectamente por la falta de entrada para esa direcci\xF3n en\
    \ las tablas de excepci\xF3n. Pero despu\xE9s de esa confirmaci\xF3n, el kernel\
    \ depende principalmente de KUAP o del manejo de mm del n\xFAcleo para detectar\
    \ accesos de usuarios incorrectos. Aqu\xED el acceso no es incorrecto, por lo\
    \ que mm lo maneja. Es un fallo menor porque PAGE_EXEC no est\xE1 configurada,\
    \ set_access_flags_filter() deber\xEDa configurar PAGE_EXEC y listo. Pero como\
    \ is_exec_fault() devuelve false como se explic\xF3 al principio, set_access_flags_filter()\
    \ sale sin configurar el indicador PAGE_EXEC, lo que conduce a un fallo de ejecuci\xF3\
    n menor para siempre. Como el kernel no est\xE1 preparado para manejar tales fallos\
    \ de ejecuci\xF3n, lo que hay que hacer es activar bad_kernel_fault() para cualquier\
    \ fallo de ejecuci\xF3n tomado por el kernel, como estaba antes de la confirmaci\xF3\
    n d3ca587404b3."
id: CVE-2021-47350
lastModified: '2024-05-21T16:54:26.047'
metrics: {}
published: '2024-05-21T15:15:21.483'
references:
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/500f81cec9f1bfa5210aa9dd5ba9a06e22f62a35
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/8a96ec5ebf96ad8e2ba7b1b34103a0be5140fc70
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/a82471a14aad90f79d1608d2bcbb019f0ffb53f0
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/cd5d5e602f502895e47e18cd46804d6d7014e65c
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/d2e52d4664097a6c1f591d869ec594bd7a0d4925
sourceIdentifier: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
vulnStatus: Awaiting Analysis
