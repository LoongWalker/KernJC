cveTags: []
descriptions:
- lang: en
  value: "In the Linux kernel, the following vulnerability has been resolved:\n\n\
    tcp: fix tcp_init_transfer() to not reset icsk_ca_initialized\n\nThis commit fixes\
    \ a bug (found by syzkaller) that could cause spurious\ndouble-initializations\
    \ for congestion control modules, which could cause\nmemory leaks or other problems\
    \ for congestion control modules (like CDG)\nthat allocate memory in their init\
    \ functions.\n\nThe buggy scenario constructed by syzkaller was something like:\n\
    \n(1) create a TCP socket\n(2) initiate a TFO connect via sendto()\n(3) while\
    \ socket is in TCP_SYN_SENT, call setsockopt(TCP_CONGESTION),\n    which calls:\n\
    \       tcp_set_congestion_control() ->\n         tcp_reinit_congestion_control()\
    \ ->\n           tcp_init_congestion_control()\n(4) receive ACK, connection is\
    \ established, call tcp_init_transfer(),\n    set icsk_ca_initialized=0 (without\
    \ first calling cc->release()),\n    call tcp_init_congestion_control() again.\n\
    \nNote that in this sequence tcp_init_congestion_control() is called\ntwice without\
    \ a cc->release() call in between. Thus, for CC modules\nthat allocate memory\
    \ in their init() function, e.g, CDG, a memory leak\nmay occur. The syzkaller\
    \ tool managed to find a reproducer that\ntriggered such a leak in CDG.\n\nThe\
    \ bug was introduced when that commit 8919a9b31eb4 (\"tcp: Only init\ncongestion\
    \ control if not initialized already\")\nintroduced icsk_ca_initialized and set\
    \ icsk_ca_initialized to 0 in\ntcp_init_transfer(), missing the possibility for\
    \ a sequence like the\none above, where a process could call setsockopt(TCP_CONGESTION)\
    \ in\nstate TCP_SYN_SENT (i.e. after the connect() or TFO open sendmsg()),\nwhich\
    \ would call tcp_init_congestion_control(). It did not intend to\nreset any initialization\
    \ that the user had already explicitly made;\nit just missed the possibility of\
    \ that particular sequence (which\nsyzkaller managed to find)."
- lang: es
  value: "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: tcp:\
    \ corrige tcp_init_transfer() para no restablecer icsk_ca_initialized Esta confirmaci\xF3\
    n corrige un error (encontrado por syzkaller) que podr\xEDa causar dobles inicializaciones\
    \ falsas para los m\xF3dulos de control de congesti\xF3n, lo que podr\xEDa causar\
    \ p\xE9rdidas de memoria o Otros problemas para los m\xF3dulos de control de congesti\xF3\
    n (como CDG) que asignan memoria en sus funciones de inicio. El escenario con\
    \ errores construido por syzkaller era algo as\xED como: (1) crear un socket TCP\
    \ (2) iniciar una conexi\xF3n TFO a trav\xE9s de sendto() (3) mientras el socket\
    \ est\xE1 en TCP_SYN_SENT, llamar a setsockopt(TCP_CONGESTION), que llama a: tcp_set_congestion_control()\
    \ - &gt; tcp_reinit_congestion_control() -&gt; tcp_init_congestion_control() (4)\
    \ recibe ACK, se establece la conexi\xF3n, llama a tcp_init_transfer(), establece\
    \ icsk_ca_initialized=0 (sin llamar primero a cc-&gt;release()), llama a tcp_init_congestion_control()\
    \ nuevamente. Tenga en cuenta que en esta secuencia tcp_init_congestion_control()\
    \ se llama dos veces sin una llamada cc-&gt;release() en el medio. Por lo tanto,\
    \ para los m\xF3dulos CC que asignan memoria en su funci\xF3n init(), por ejemplo,\
    \ CDG, puede ocurrir una p\xE9rdida de memoria. La herramienta syzkaller logr\xF3\
    \ encontrar un reproductor que desencaden\xF3 dicha filtraci\xF3n en CDG. El error\
    \ se introdujo cuando la confirmaci\xF3n 8919a9b31eb4 (\"tcp: solo inicia el control\
    \ de congesti\xF3n si a\xFAn no est\xE1 inicializado\") introdujo icsk_ca_initialized\
    \ y estableci\xF3 icsk_ca_initialized en 0 en tcp_init_transfer(), perdiendo la\
    \ posibilidad de una secuencia como la anterior, donde un proceso podr\xEDa llamar\
    \ setsockopt(TCP_CONGESTION) en el estado TCP_SYN_SENT (es decir, despu\xE9s de\
    \ connect() o TFO open sendmsg()), que llamar\xEDa a tcp_init_congestion_control().\
    \ No ten\xEDa la intenci\xF3n de restablecer ninguna inicializaci\xF3n que el\
    \ usuario ya hubiera realizado expl\xEDcitamente; simplemente perdi\xF3 la posibilidad\
    \ de esa secuencia particular (que Syzkaller logr\xF3 encontrar)."
id: CVE-2021-47304
lastModified: '2024-05-21T16:54:26.047'
metrics: {}
published: '2024-05-21T15:15:18.110'
references:
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/ad4ba3404931745a5977ad12db4f0c34080e52f7
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/be5d1b61a2ad28c7e57fe8bfa277373e8ecffcdc
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/fe77b85828ca9ddc42977b79de9e40d18545b4fe
sourceIdentifier: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
vulnStatus: Awaiting Analysis
