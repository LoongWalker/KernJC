cveTags: []
descriptions:
- lang: en
  value: "In the Linux kernel, the following vulnerability has been resolved:\n\n\
    KVM: PPC: Book3S HV: Fix stack handling in idle_kvm_start_guest()\n\nIn commit\
    \ 10d91611f426 (\"powerpc/64s: Reimplement book3s idle code in\nC\") kvm_start_guest()\
    \ became idle_kvm_start_guest(). The old code\nallocated a stack frame on the\
    \ emergency stack, but didn't use the\nframe to store anything, and also didn't\
    \ store anything in its caller's\nframe.\n\nidle_kvm_start_guest() on the other\
    \ hand is written more like a normal C\nfunction, it creates a frame on entry,\
    \ and also stores CR/LR into its\ncallers frame (per the ABI). The problem is\
    \ that there is no caller\nframe on the emergency stack.\n\nThe emergency stack\
    \ for a given CPU is allocated with:\n\n  paca_ptrs[i]->emergency_sp = alloc_stack(limit,\
    \ i) + THREAD_SIZE;\n\nSo emergency_sp actually points to the first address above\
    \ the emergency\nstack allocation for a given CPU, we must not store above it\
    \ without\nfirst decrementing it to create a frame. This is different to the\n\
    regular kernel stack, paca->kstack, which is initialised to point at an\ninitial\
    \ frame that is ready to use.\n\nidle_kvm_start_guest() stores the backchain,\
    \ CR and LR all of which\nwrite outside the allocation for the emergency stack.\
    \ It then creates a\nstack frame and saves the non-volatile registers. Unfortunately\
    \ the\nframe it creates is not large enough to fit the non-volatiles, and so\n\
    the saving of the non-volatile registers also writes outside the\nemergency stack\
    \ allocation.\n\nThe end result is that we corrupt whatever is at 0-24 bytes,\
    \ and 112-248\nbytes above the emergency stack allocation.\n\nIn practice this\
    \ has gone unnoticed because the memory immediately above\nthe emergency stack\
    \ happens to be used for other stack allocations,\neither another CPUs mc_emergency_sp\
    \ or an IRQ stack. See the order of\ncalls to irqstack_early_init() and emergency_stack_init().\n\
    \nThe low addresses of another stack are the top of that stack, and so are\nonly\
    \ used if that stack is under extreme pressue, which essentially\nnever happens\
    \ in practice - and if it did there's a high likelyhood we'd\ncrash due to that\
    \ stack overflowing.\n\nStill, we shouldn't be corrupting someone else's stack,\
    \ and it is purely\nluck that we aren't corrupting something else.\n\nTo fix it\
    \ we save CR/LR into the caller's frame using the existing r1 on\nentry, we then\
    \ create a SWITCH_FRAME_SIZE frame (which has space for\npt_regs) on the emergency\
    \ stack with the backchain pointing to the\nexisting stack, and then finally we\
    \ switch to the new frame on the\nemergency stack."
- lang: es
  value: "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: KVM:\
    \ PPC: Book3S HV: Arreglar el manejo de la pila en idle_kvm_start_guest() En el\
    \ commit 10d91611f426 (\"powerpc/64s: Reimplementar el c\xF3digo inactivo de book3s\
    \ en C\") kvm_start_guest() se convirti\xF3 en idle_kvm_start_guest() . El c\xF3\
    digo antiguo asignaba un marco de pila en la pila de emergencia, pero no usaba\
    \ el marco para almacenar nada y tampoco almacenaba nada en el marco de la persona\
    \ que llama. idle_kvm_start_guest(), por otro lado, se escribe m\xE1s como una\
    \ funci\xF3n C normal, crea un marco al ingresar y tambi\xE9n almacena CR/LR en\
    \ el marco de la persona que llama (seg\xFAn la ABI). El problema es que no hay\
    \ ning\xFAn marco de llamada en la pila de emergencia. La pila de emergencia para\
    \ una CPU determinada se asigna con: paca_ptrs[i]-&gt;emergency_sp = alloc_stack(limit,\
    \ i) + THREAD_SIZE; Entonces, Emergency_sp en realidad apunta a la primera direcci\xF3\
    n encima de la asignaci\xF3n de pila de emergencia para una CPU determinada; no\
    \ debemos almacenar encima de ella sin primero disminuirla para crear un marco.\
    \ Esto es diferente a la pila normal del kernel, paca-&gt;kstack, que se inicializa\
    \ para apuntar a un marco inicial que est\xE1 listo para usar. idle_kvm_start_guest()\
    \ almacena la cadena posterior, CR y LR, todos los cuales escriben fuera de la\
    \ asignaci\xF3n para la pila de emergencia. Luego crea un marco de pila y guarda\
    \ los registros no vol\xE1tiles. Desafortunadamente, el marco que crea no es lo\
    \ suficientemente grande para acomodar los registros no vol\xE1tiles, por lo que\
    \ guardar los registros no vol\xE1tiles tambi\xE9n escribe fuera de la asignaci\xF3\
    n de pila de emergencia. El resultado final es que corrompemos todo lo que est\xE9\
    \ entre 0 y 24 bytes y entre 112 y 248 bytes por encima de la asignaci\xF3n de\
    \ pila de emergencia. En la pr\xE1ctica, esto ha pasado desapercibido porque la\
    \ memoria inmediatamente encima de la pila de emergencia se usa para otras asignaciones\
    \ de pila, ya sea otra CPU mc_emergency_sp o una pila IRQ. Vea el orden de las\
    \ llamadas a irqstack_early_init() y Emergency_stack_init(). Las direcciones bajas\
    \ de otra pila est\xE1n en la parte superior de esa pila, por lo que solo se usan\
    \ si esa pila est\xE1 bajo una presi\xF3n extrema, lo que esencialmente nunca\
    \ sucede en la pr\xE1ctica, y si as\xED fuera, existe una alta probabilidad de\
    \ que fallemos debido a que esa pila se desborde. . A\xFAn as\xED, no deber\xED\
    amos estar corrompiendo la pila de otra persona, y es pura suerte que no estemos\
    \ corrompiendo algo m\xE1s. Para solucionarlo, guardamos CR/LR en el marco de\
    \ la persona que llama usando el r1 existente en la entrada, luego creamos un\
    \ marco SWITCH_FRAME_SIZE (que tiene espacio para pt_regs) en la pila de emergencia\
    \ con la cadena posterior apuntando a la pila existente, y finalmente cambiamos\
    \ al nuevo marco en la pila de emergencia."
id: CVE-2021-47465
lastModified: '2024-05-22T12:46:53.887'
metrics: {}
published: '2024-05-22T07:15:11.367'
references:
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/6d077c37c4643394b1bae9682da48164fc147ea8
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/80bbb0bc3a0288442f7fe6fc514f4ee1cb06ccb7
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/9b4416c5095c20e110c82ae602c254099b83b72f
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/fbd724c49bead048ae9fc1a5b7bff2fb3e54f855
sourceIdentifier: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
vulnStatus: Awaiting Analysis
