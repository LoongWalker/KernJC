cveTags: []
descriptions:
- lang: en
  value: "In the Linux kernel, the following vulnerability has been resolved:\n\n\
    bpf, lockdown, audit: Fix buggy SELinux lockdown permission checks\n\nCommit 59438b46471a\
    \ (\"security,lockdown,selinux: implement SELinux lockdown\")\nadded an implementation\
    \ of the locked_down LSM hook to SELinux, with the aim\nto restrict which domains\
    \ are allowed to perform operations that would breach\nlockdown. This is indirectly\
    \ also getting audit subsystem involved to report\nevents. The latter is problematic,\
    \ as reported by Ondrej and Serhei, since it\ncan bring down the whole system\
    \ via audit:\n\n  1) The audit events that are triggered due to calls to security_locked_down()\n\
    \     can OOM kill a machine, see below details [0].\n\n  2) It also seems to\
    \ be causing a deadlock via avc_has_perm()/slow_avc_audit()\n     when trying\
    \ to wake up kauditd, for example, when using trace_sched_switch()\n     tracepoint,\
    \ see details in [1]. Triggering this was not via some hypothetical\n     corner\
    \ case, but with existing tools like runqlat & runqslower from bcc, for\n    \
    \ example, which make use of this tracepoint. Rough call sequence goes like:\n\
    \n     rq_lock(rq) -> -------------------------+\n       trace_sched_switch()\
    \ ->               |\n         bpf_prog_xyz() ->                   +-> deadlock\n\
    \           selinux_lockdown() ->             |\n             audit_log_end()\
    \ ->              |\n               wake_up_interruptible() ->    |\n        \
    \         try_to_wake_up() ->         |\n                   rq_lock(rq) --------------+\n\
    \nWhat's worse is that the intention of 59438b46471a to further restrict lockdown\n\
    settings for specific applications in respect to the global lockdown policy is\n\
    completely broken for BPF. The SELinux policy rule for the current lockdown check\n\
    looks something like this:\n\n  allow <who> <who> : lockdown { <reason> };\n\n\
    However, this doesn't match with the 'current' task where the security_locked_down()\n\
    is executed, example: httpd does a syscall. There is a tracing program attached\n\
    to the syscall which triggers a BPF program to run, which ends up doing a\nbpf_probe_read_kernel{,_str}()\
    \ helper call. The selinux_lockdown() hook does\nthe permission check against\
    \ 'current', that is, httpd in this example. httpd\nhas literally zero relation\
    \ to this tracing program, and it would be nonsensical\nhaving to write an SELinux\
    \ policy rule against httpd to let the tracing helper\npass. The policy in this\
    \ case needs to be against the entity that is installing\nthe BPF program. For\
    \ example, if bpftrace would generate a histogram of syscall\ncounts by user space\
    \ application:\n\n  bpftrace -e 'tracepoint:raw_syscalls:sys_enter { @[comm] =\
    \ count(); }'\n\nbpftrace would then go and generate a BPF program from this internally.\
    \ One way\nof doing it [for the sake of the example] could be to call bpf_get_current_task()\n\
    helper and then access current->comm via one of bpf_probe_read_kernel{,_str}()\n\
    helpers. So the program itself has nothing to do with httpd or any other random\n\
    app doing a syscall here. The BPF program _explicitly initiated_ the lockdown\n\
    check. The allow/deny policy belongs in the context of bpftrace: meaning, you\n\
    want to grant bpftrace access to use these helpers, but other tracers on the\n\
    system like my_random_tracer _not_.\n\nTherefore fix all three issues at the same\
    \ time by taking a completely different\napproach for the security_locked_down()\
    \ hook, that is, move the check into the\nprogram verification phase where we\
    \ actually retrieve the BPF func proto. This\nalso reliably gets the task (current)\
    \ that is trying to install the BPF tracing\nprogram, e.g. bpftrace/bcc/perf/systemtap/etc,\
    \ and it also fixes the OOM since\nwe're moving this out of the BPF helper's fast-path\
    \ which can be called several\nmillions of times per second.\n\nThe check is then\
    \ also in line with other security_locked_down() hooks in the\nsystem where the\
    \ enforcement is performed at open/load time, for example,\nopen_kcore() for /proc/kcore\
    \ access or module_sig_check() for module signatures\njust to pick f\n---truncated---"
- lang: es
  value: "En el kernel de Linux, se resolvi\xF3 la siguiente vulnerabilidad: bpf,\
    \ bloqueo, auditor\xEDa: se corrigieron las comprobaciones de permisos de bloqueo\
    \ de SELinux con errores. El commit 59438b46471a (\"seguridad, bloqueo, selinux:\
    \ implementar bloqueo de SELinux\") agreg\xF3 una implementaci\xF3n del gancho\
    \ LSM lock_down a SELinux. con el objetivo de restringir qu\xE9 dominios pueden\
    \ realizar operaciones que violar\xEDan el bloqueo. Indirectamente, esto tambi\xE9\
    n implica involucrar al subsistema de auditor\xEDa para informar eventos. Esto\
    \ \xFAltimo es problem\xE1tico, como informaron Ondrej y Serhei, ya que puede\
    \ hacer caer todo el sistema a trav\xE9s de una auditor\xEDa: 1) Los eventos de\
    \ auditor\xEDa que se activan debido a llamadas a security_locked_down() pueden\
    \ OOM matar una m\xE1quina, vea los detalles a continuaci\xF3n [0] . 2) Tambi\xE9\
    n parece estar causando un punto muerto a trav\xE9s de avc_has_perm()/slow_avc_audit()\
    \ cuando se intenta activar kauditd, por ejemplo, cuando se usa el punto de seguimiento\
    \ trace_sched_switch(), consulte los detalles en [1]. Esto no se activ\xF3 a trav\xE9\
    s de alg\xFAn caso hipot\xE9tico de esquina, sino con herramientas existentes\
    \ como runqlat y runqslower de bcc, por ejemplo, que hacen uso de este punto de\
    \ seguimiento. La secuencia de llamada aproximada es as\xED: rq_lock(rq) -&gt;\
    \ -------------------------+ trace_sched_switch() -&gt; | bpf_prog_xyz() -&gt;\
    \ +-&gt; punto muerto selinux_lockdown() -&gt; | audit_log_end() -&gt; | wake_up_interruptible()\
    \ -&gt; | try_to_wake_up() -&gt; | rq_lock(rq) --------------+ Lo que es peor\
    \ es que la intenci\xF3n de 59438b46471a de restringir a\xFAn m\xE1s la configuraci\xF3\
    n de bloqueo para aplicaciones espec\xEDficas con respecto a la pol\xEDtica de\
    \ bloqueo global no es v\xE1lida para BPF. La regla de pol\xEDtica de SELinux\
    \ para la verificaci\xF3n de bloqueo actual se parece a esto: permitir   : bloqueo\
    \ {  }; Sin embargo, esto no coincide con la tarea 'actual' donde se ejecuta security_locked_down(),\
    \ ejemplo: httpd realiza una llamada al sistema. Hay un programa de seguimiento\
    \ adjunto a la llamada al sistema que activa la ejecuci\xF3n de un programa BPF,\
    \ que termina realizando una llamada de ayuda bpf_probe_read_kernel{,_str}().\
    \ El gancho selinux_lockdown() realiza la verificaci\xF3n de permisos con respecto\
    \ a 'actual', es decir, httpd en este ejemplo. httpd tiene literalmente cero relaci\xF3\
    n con este programa de rastreo, y no tendr\xEDa sentido tener que escribir una\
    \ regla de pol\xEDtica SELinux contra httpd para permitir que pase el asistente\
    \ de rastreo. La pol\xEDtica en este caso debe ser contra la entidad que est\xE1\
    \ instalando el programa BPF. Por ejemplo, si bpftrace generara un histograma\
    \ de recuentos de llamadas al sistema por aplicaci\xF3n de espacio de usuario:\
    \ bpftrace -e 'tracepoint:raw_syscalls:sys_enter { @[comm] = count(); }' bpftrace\
    \ luego generar\xEDa un programa BPF a partir de esto internamente. Una forma\
    \ de hacerlo [por el bien del ejemplo] podr\xEDa ser llamar al asistente bpf_get_current_task()\
    \ y luego acceder a current-&gt;comm a trav\xE9s de uno de los asistentes bpf_probe_read_kernel{,_str}().\
    \ Entonces, el programa en s\xED no tiene nada que ver con httpd o cualquier otra\
    \ aplicaci\xF3n aleatoria que realice una llamada al sistema aqu\xED. El programa\
    \ BPF _inici\xF3 expl\xEDcitamente_ la verificaci\xF3n del bloqueo. La pol\xED\
    tica de permitir/denegar pertenece al contexto de bpftrace: es decir, desea otorgar\
    \ acceso a bpftrace para usar estos asistentes, pero otros rastreadores en el\
    \ sistema como my_random_tracer _no_. Por lo tanto, solucione los tres problemas\
    \ al mismo tiempo adoptando un enfoque completamente diferente para el enlace\
    \ security_locked_down(), es decir, mueva la verificaci\xF3n a la fase de verificaci\xF3\
    n del programa donde realmente recuperamos el protocolo de funci\xF3n BPF. Esto\
    \ tambi\xE9n obtiene de manera confiable la tarea (actual) que est\xE1 intentando\
    \ instalar el programa de rastreo de BPF, por ejemplo, bpftrace/bcc/perf/systemtap/etc,---truncado---"
id: CVE-2021-47128
lastModified: '2024-03-17T22:38:29.433'
metrics: {}
published: '2024-03-15T21:15:07.470'
references:
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/acc43fc6cf0d50612193813c5906a1ab9d433e1e
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/ff40e51043af63715ab413995ff46996ecf9583f
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/ff5039ec75c83d2ed5b781dc7733420ee8c985fc
sourceIdentifier: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
vulnStatus: Awaiting Analysis
