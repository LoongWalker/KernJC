cveTags: []
descriptions:
- lang: en
  value: 'In the Linux kernel, the following vulnerability has been resolved:


    x86/fpu: Prevent state corruption in __fpu__restore_sig()


    The non-compacted slowpath uses __copy_from_user() and copies the entire

    user buffer into the kernel buffer, verbatim.  This means that the kernel

    buffer may now contain entirely invalid state on which XRSTOR will #GP.

    validate_user_xstate_header() can detect some of that corruption, but that

    leaves the onus on callers to clear the buffer.


    Prior to XSAVES support, it was possible just to reinitialize the buffer,

    completely, but with supervisor states that is not longer possible as the

    buffer clearing code split got it backwards. Fixing that is possible but

    not corrupting the state in the first place is more robust.


    Avoid corruption of the kernel XSAVE buffer by using copy_user_to_xstate()

    which validates the XSAVE header contents before copying the actual states

    to the kernel. copy_user_to_xstate() was previously only called for

    compacted-format kernel buffers, but it works for both compacted and

    non-compacted forms.


    Using it for the non-compacted form is slower because of multiple

    __copy_from_user() operations, but that cost is less important than robust

    code in an already slow path.


    [ Changelog polished by Dave Hansen ]'
- lang: es
  value: "En el kernel de Linux, se resolvi\xF3 la siguiente vulnerabilidad: x86/fpu:\
    \ evita la corrupci\xF3n del estado en __fpu__restore_sig() La ruta lenta no compactada\
    \ usa __copy_from_user() y copia todo el b\xFAfer del usuario en el b\xFAfer del\
    \ kernel, palabra por palabra. Esto significa que el b\xFAfer del kernel ahora\
    \ puede contener un estado completamente inv\xE1lido en el que XRSTOR realizar\xE1\
    \ #GP. validar_user_xstate_header() puede detectar parte de esa corrupci\xF3n,\
    \ pero eso deja a las personas que llaman la responsabilidad de borrar el b\xFA\
    fer. Antes de la compatibilidad con XSAVES, era posible simplemente reinicializar\
    \ el b\xFAfer por completo, pero con los estados del supervisor eso ya no es posible\
    \ porque la divisi\xF3n del c\xF3digo de borrado del b\xFAfer lo hac\xEDa al rev\xE9\
    s. Arreglar eso es posible, pero no corromper al Estado en primer lugar es m\xE1\
    s s\xF3lido. Evite la corrupci\xF3n del b\xFAfer XSAVE del kernel utilizando copy_user_to_xstate()\
    \ que valida el contenido del encabezado XSAVE antes de copiar los estados reales\
    \ al kernel. copy_user_to_xstate() anteriormente solo se llamaba para buffers\
    \ del kernel en formato compacto, pero funciona tanto para formatos compactos\
    \ como no compactos. Usarlo para el formato no compacto es m\xE1s lento debido\
    \ a m\xFAltiples operaciones __copy_from_user(), pero ese costo es menos importante\
    \ que el c\xF3digo robusto en una ruta que ya es lenta. [Registro de cambios pulido\
    \ por Dave Hansen]"
id: CVE-2021-47227
lastModified: '2024-05-21T16:54:26.047'
metrics: {}
published: '2024-05-21T15:15:11.900'
references:
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/076f732b16a5bf842686e1b43ab6021a2d98233e
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/484cea4f362e1eeb5c869abbfb5f90eae6421b38
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/ec25ea1f3f05d6f8ee51d1277efea986eafd4f2a
sourceIdentifier: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
vulnStatus: Awaiting Analysis
