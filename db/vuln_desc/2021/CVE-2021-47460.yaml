cveTags: []
descriptions:
- lang: en
  value: "In the Linux kernel, the following vulnerability has been resolved:\n\n\
    ocfs2: fix data corruption after conversion from inline format\n\nCommit 6dbf7bb55598\
    \ (\"fs: Don't invalidate page buffers in\nblock_write_full_page()\") uncovered\
    \ a latent bug in ocfs2 conversion\nfrom inline inode format to a normal inode\
    \ format.\n\nThe code in ocfs2_convert_inline_data_to_extents() attempts to zero\
    \ out\nthe whole cluster allocated for file data by grabbing, zeroing, and\ndirtying\
    \ all pages covering this cluster.  However these pages are\nbeyond i_size, thus\
    \ writeback code generally ignores these dirty pages\nand no blocks were ever\
    \ actually zeroed on the disk.\n\nThis oversight was fixed by commit 693c241a5f6a\
    \ (\"ocfs2: No need to zero\npages past i_size.\") for standard ocfs2 write path,\
    \ inline conversion\npath was apparently forgotten; the commit log also has a\
    \ reasoning why\nthe zeroing actually is not needed.\n\nAfter commit 6dbf7bb55598,\
    \ things became worse as writeback code stopped\ninvalidating buffers on pages\
    \ beyond i_size and thus these pages end up\nwith clean PageDirty bit but with\
    \ buffers attached to these pages being\nstill dirty.  So when a file is converted\
    \ from inline format, then\nwriteback triggers, and then the file is grown so\
    \ that these pages\nbecome valid, the invalid dirtiness state is preserved,\n\
    mark_buffer_dirty() does nothing on these pages (buffers are already\ndirty) but\
    \ page is never written back because it is clean.  So data\nwritten to these pages\
    \ is lost once pages are reclaimed.\n\nSimple reproducer for the problem is:\n\
    \n  xfs_io -f -c \"pwrite 0 2000\" -c \"pwrite 2000 2000\" -c \"fsync\" \\\n \
    \   -c \"pwrite 4000 2000\" ocfs2_file\n\nAfter unmounting and mounting the fs\
    \ again, you can observe that end of\n'ocfs2_file' has lost its contents.\n\n\
    Fix the problem by not doing the pointless zeroing during conversion\nfrom inline\
    \ format similarly as in the standard write path.\n\n[akpm@linux-foundation.org:\
    \ fix whitespace, per Joseph]"
- lang: es
  value: "En el kernel de Linux, se resolvi\xF3 la siguiente vulnerabilidad: ocfs2:\
    \ corrige la corrupci\xF3n de datos despu\xE9s de la conversi\xF3n desde el formato\
    \ en l\xEDnea. el commit 6dbf7bb55598 (\"fs: No invalide los buffers de p\xE1\
    gina en block_write_full_page()\") descubri\xF3 un error latente en la conversi\xF3\
    n de ocfs2 desde el inodo en l\xEDnea. formato a un formato de inodo normal. El\
    \ c\xF3digo en ocfs2_convert_inline_data_to_extents() intenta poner a cero todo\
    \ el cl\xFAster asignado para datos de archivos capturando, poniendo a cero y\
    \ ensuciando todas las p\xE1ginas que cubren este cl\xFAster. Sin embargo, estas\
    \ p\xE1ginas est\xE1n m\xE1s all\xE1 de i_size, por lo que el c\xF3digo de reescritura\
    \ generalmente ignora estas p\xE1ginas sucias y nunca se puso a cero ning\xFA\
    n bloque en el disco. Este descuido se solucion\xF3 mediante el commit 693c241a5f6a\
    \ (\"ocfs2: No es necesario poner a cero las p\xE1ginas despu\xE9s de i_size.\"\
    ) para la ruta de escritura est\xE1ndar de ocfs2, la ruta de conversi\xF3n en\
    \ l\xEDnea aparentemente se olvid\xF3; el registro de confirmaci\xF3n tambi\xE9\
    n tiene un razonamiento por el cual la puesta a cero en realidad no es necesaria.\
    \ Despu\xE9s de el commit 6dbf7bb55598, las cosas empeoraron ya que el c\xF3digo\
    \ de reescritura dej\xF3 de invalidar los buffers en p\xE1ginas m\xE1s all\xE1\
    \ de i_size y, por lo tanto, estas p\xE1ginas terminan con un bit PageDirty limpio\
    \ pero con los b\xFAferes adjuntos a estas p\xE1ginas todav\xEDa sucios. Entonces,\
    \ cuando un archivo se convierte desde un formato en l\xEDnea, se activa la reescritura\
    \ y luego el archivo crece para que estas p\xE1ginas se vuelvan v\xE1lidas, se\
    \ conserva el estado de suciedad no v\xE1lido, mark_buffer_dirty() no hace nada\
    \ en estas p\xE1ginas (los b\xFAferes ya est\xE1n sucios), excepto la p\xE1gina\
    \ nunca se vuelve a escribir porque est\xE1 limpio. Por lo tanto, los datos escritos\
    \ en estas p\xE1ginas se pierden una vez que se recuperan las p\xE1ginas. El reproductor\
    \ simple para el problema es: xfs_io -f -c \"pwrite 0 2000\" -c \"pwrite 2000\
    \ 2000\" -c \"fsync\" \\ -c \"pwrite 4000 2000\" ocfs2_file Despu\xE9s de desmontar\
    \ y montar el fs nuevamente, puede observar que El final de 'ocfs2_file' ha perdido\
    \ su contenido. Solucione el problema al no realizar la puesta a cero in\xFAtil\
    \ durante la conversi\xF3n desde el formato en l\xEDnea de manera similar a como\
    \ lo hace en la ruta de escritura est\xE1ndar. [akpm@linux-foundation.org: arreglar\
    \ espacios en blanco, seg\xFAn Joseph]"
id: CVE-2021-47460
lastModified: '2024-05-22T12:46:53.887'
metrics: {}
published: '2024-05-22T07:15:10.940'
references:
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/5314454ea3ff6fc746eaf71b9a7ceebed52888fa
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/560edd14de2bf9dbc0129681eeb4d5ef87cc105f
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/8e6bfb4f70168ddfd32fb6dc028ad52faaf1f32e
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/a3a089c241cd49b33a8cdd7fcb37cc87a086912a
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/b05caf023b14cbed9223bb5b48ecc7bffe38f632
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/f1b98569e81c37d7e0deada7172f8f60860c1360
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/fa9b6b6c953e3f6441ed6cf83b4c771dac2dae08
sourceIdentifier: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
vulnStatus: Awaiting Analysis
