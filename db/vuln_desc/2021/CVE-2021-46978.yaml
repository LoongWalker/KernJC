descriptions:
- lang: en
  value: 'In the Linux kernel, the following vulnerability has been resolved:


    KVM: nVMX: Always make an attempt to map eVMCS after migration


    When enlightened VMCS is in use and nested state is migrated with

    vmx_get_nested_state()/vmx_set_nested_state() KVM can''t map evmcs

    page right away: evmcs gpa is not ''struct kvm_vmx_nested_state_hdr''

    and we can''t read it from VP assist page because userspace may decide

    to restore HV_X64_MSR_VP_ASSIST_PAGE after restoring nested state

    (and QEMU, for example, does exactly that). To make sure eVMCS is

    mapped /vmx_set_nested_state() raises KVM_REQ_GET_NESTED_STATE_PAGES

    request.


    Commit f2c7ef3ba955 ("KVM: nSVM: cancel KVM_REQ_GET_NESTED_STATE_PAGES

    on nested vmexit") added KVM_REQ_GET_NESTED_STATE_PAGES clearing to

    nested_vmx_vmexit() to make sure MSR permission bitmap is not switched

    when an immediate exit from L2 to L1 happens right after migration (caused

    by a pending event, for example). Unfortunately, in the exact same

    situation we still need to have eVMCS mapped so

    nested_sync_vmcs12_to_shadow() reflects changes in VMCS12 to eVMCS.


    As a band-aid, restore nested_get_evmcs_page() when clearing

    KVM_REQ_GET_NESTED_STATE_PAGES in nested_vmx_vmexit(). The ''fix'' is far

    from being ideal as we can''t easily propagate possible failures and even if

    we could, this is most likely already too late to do so. The whole

    ''KVM_REQ_GET_NESTED_STATE_PAGES'' idea for mapping eVMCS after migration

    seems to be fragile as we diverge too much from the ''native'' path when

    vmptr loading happens on vmx_set_nested_state().'
- lang: es
  value: "En el kernel de Linux, se resolvi\xF3 la siguiente vulnerabilidad: KVM:\
    \ nVMX: siempre intente asignar eVMCS despu\xE9s de la migraci\xF3n Cuando se\
    \ utiliza VMCS iluminado y el estado anidado se migra con vmx_get_nested_state()/vmx_set_nested_state()\
    \ KVM no puede asignar evmcs p\xE1gina de inmediato: evmcs gpa no es 'struct kvm_vmx_nested_state_hdr'\
    \ y no podemos leerlo desde la p\xE1gina de asistencia de VP porque el espacio\
    \ de usuario puede decidir restaurar HV_X64_MSR_VP_ASSIST_PAGE despu\xE9s de restaurar\
    \ el estado anidado (y QEMU, por ejemplo, hace exactamente eso). Para asegurarse\
    \ de que eVMCS est\xE9 asignado, /vmx_set_nested_state() genera la solicitud KVM_REQ_GET_NESTED_STATE_PAGES.\
    \ el commit f2c7ef3ba955 (\"KVM: nSVM: cancelar KVM_REQ_GET_NESTED_STATE_PAGES\
    \ en vmexit anidado\") agreg\xF3 la limpieza KVM_REQ_GET_NESTED_STATE_PAGES a\
    \ nested_vmx_vmexit() para asegurarse de que el mapa de bits del permiso MSR no\
    \ se cambie cuando ocurre una salida inmediata de L2 a L1 justo despu\xE9s de\
    \ la migraci\xF3n (causada por un evento pendiente, Por ejemplo). Desafortunadamente,\
    \ en exactamente la misma situaci\xF3n todav\xEDa necesitamos tener eVMCS mapeado\
    \ para que nested_sync_vmcs12_to_shadow() refleje los cambios en VMCS12 a eVMCS.\
    \ Como curita, restaure nested_get_evmcs_page() al borrar KVM_REQ_GET_NESTED_STATE_PAGES\
    \ en nested_vmx_vmexit(). La \"soluci\xF3n\" est\xE1 lejos de ser ideal, ya que\
    \ no podemos propagar f\xE1cilmente posibles fallas e incluso si pudi\xE9ramos,\
    \ lo m\xE1s probable es que ya sea demasiado tarde para hacerlo. Toda la idea\
    \ 'KVM_REQ_GET_NESTED_STATE_PAGES' para mapear eVMCS despu\xE9s de la migraci\xF3\
    n parece ser fr\xE1gil ya que nos desviamos demasiado de la ruta 'nativa' cuando\
    \ la carga de vmptr ocurre en vmx_set_nested_state()."
id: CVE-2021-46978
lastModified: '2024-02-28T14:06:45.783'
metrics: {}
published: '2024-02-28T09:15:37.183'
references:
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/200a45649ab7361bc80c70aebf7165b64f9a6c9f
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/bd0e8455b85b651a4c77de9616e307129b15aaa7
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/c8bf64e3fb77cc19bad146fbe26651985b117194
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/f5c7e8425f18fdb9bdb7d13340651d7876890329
sourceIdentifier: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
vulnStatus: Awaiting Analysis
