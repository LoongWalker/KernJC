descriptions:
- lang: en
  value: 'In the Linux kernel, the following vulnerability has been resolved:


    s390/qeth: fix NULL deref in qeth_clear_working_pool_list()


    When qeth_set_online() calls qeth_clear_working_pool_list() to roll

    back after an error exit from qeth_hardsetup_card(), we are at risk of

    accessing card->qdio.in_q before it was allocated by

    qeth_alloc_qdio_queues() via qeth_mpc_initialize().


    qeth_clear_working_pool_list() then dereferences NULL, and by writing to

    queue->bufs[i].pool_entry scribbles all over the CPU''s lowcore.

    Resulting in a crash when those lowcore areas are used next (eg. on

    the next machine-check interrupt).


    Such a scenario would typically happen when the device is first set

    online and its queues aren''t allocated yet. An early IO error or certain

    misconfigs (eg. mismatched transport mode, bad portno) then cause us to

    error out from qeth_hardsetup_card() with card->qdio.in_q still being

    NULL.


    Fix it by checking the pointer for NULL before accessing it.


    Note that we also have (rare) paths inside qeth_mpc_initialize() where

    a configuration change can cause us to free the existing queues,

    expecting that subsequent code will allocate them again. If we then

    error out before that re-allocation happens, the same bug occurs.


    Root-caused-by: Heiko Carstens <hca@linux.ibm.com>'
- lang: es
  value: "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: s390/qeth:\
    \ corrige NULL deref en qeth_clear_working_pool_list(). Cuando qeth_set_online()\
    \ llama a qeth_clear_working_pool_list() para retroceder despu\xE9s de una salida\
    \ de error de qeth_hardsetup_card(), corremos el riesgo de acceder a la tarjeta\
    \ -&gt;qdio.in_q antes de que qeth_alloc_qdio_queues() lo asignara mediante qeth_mpc_initialize().\
    \ qeth_clear_working_pool_list() luego elimina la referencia a NULL y, al escribir\
    \ en queue-&gt;bufs[i].pool_entry garabatea por todo el n\xFAcleo bajo de la CPU.\
    \ Lo que resulta en un bloqueo cuando esas \xE1reas de n\xFAcleo bajo se usan\
    \ a continuaci\xF3n (por ejemplo, en la siguiente interrupci\xF3n de verificaci\xF3\
    n de la m\xE1quina). Este escenario suele ocurrir cuando el dispositivo se configura\
    \ en l\xEDnea por primera vez y sus colas a\xFAn no est\xE1n asignadas. Un error\
    \ de IO temprano o ciertas configuraciones err\xF3neas (por ejemplo, modo de transporte\
    \ no coincidente, n\xFAmero de puerto incorrecto) hacen que salgamos del error\
    \ qeth_hardsetup_card() con card-&gt;qdio.in_q todav\xEDa siendo NULL. Solucionarlo\
    \ comprobando que el puntero sea NULL antes de acceder a \xE9l. Tenga en cuenta\
    \ que tambi\xE9n tenemos rutas (raras) dentro de qeth_mpc_initialize() donde un\
    \ cambio de configuraci\xF3n puede hacer que liberemos las colas existentes, esperando\
    \ que el c\xF3digo posterior las asigne nuevamente. Si luego cometemos un error\
    \ antes de que ocurra la reasignaci\xF3n, ocurre el mismo error. Analizado por:\
    \ Heiko Carstens "
id: CVE-2021-47369
lastModified: '2024-05-21T16:54:26.047'
metrics: {}
published: '2024-05-21T15:15:22.853'
references:
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/248f064af222a1f97ee02c84a98013dfbccad386
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/9b00fb12cdc9d8d1c3ffe82a78e74738127803fc
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/db94f89e1dadf693c15c2d60de0c34777cea5779
sourceIdentifier: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
vulnStatus: Awaiting Analysis
