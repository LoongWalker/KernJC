cveTags: []
descriptions:
- lang: en
  value: "In the Linux kernel, the following vulnerability has been resolved:\n\n\
    x86/fpu: Invalidate FPU state after a failed XRSTOR from a user buffer\n\nBoth\
    \ Intel and AMD consider it to be architecturally valid for XRSTOR to\nfail with\
    \ #PF but nonetheless change the register state.  The actual\nconditions under\
    \ which this might occur are unclear [1], but it seems\nplausible that this might\
    \ be triggered if one sibling thread unmaps a page\nand invalidates the shared\
    \ TLB while another sibling thread is executing\nXRSTOR on the page in question.\n\
    \n__fpu__restore_sig() can execute XRSTOR while the hardware registers\nare preserved\
    \ on behalf of a different victim task (using the\nfpu_fpregs_owner_ctx mechanism),\
    \ and, in theory, XRSTOR could fail but\nmodify the registers.\n\nIf this happens,\
    \ then there is a window in which __fpu__restore_sig()\ncould schedule out and\
    \ the victim task could schedule back in without\nreloading its own FPU registers.\
    \ This would result in part of the FPU\nstate that __fpu__restore_sig() was attempting\
    \ to load leaking into the\nvictim task's user-visible state.\n\nInvalidate preserved\
    \ FPU registers on XRSTOR failure to prevent this\nsituation from corrupting any\
    \ state.\n\n[1] Frequent readers of the errata lists might imagine \"complex\n\
    \    microarchitectural conditions\"."
- lang: es
  value: "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: x86/fpu:\
    \ Invalida el estado de la FPU despu\xE9s de un XRSTOR fallido desde un b\xFA\
    fer de usuario. Tanto Intel como AMD consideran que es arquitect\xF3nicamente\
    \ v\xE1lido que XRSTOR falle con #PF pero aun as\xED cambie el estado del registro.\
    \ . Las condiciones reales bajo las cuales esto podr\xEDa ocurrir no est\xE1n\
    \ claras [1], pero parece plausible que esto pueda desencadenarse si un hilo hermano\
    \ desasigna una p\xE1gina e invalida el TLB compartido mientras otro hilo hermano\
    \ est\xE1 ejecutando XRSTOR en la p\xE1gina en cuesti\xF3n. __fpu__restore_sig()\
    \ puede ejecutar XRSTOR mientras los registros de hardware se conservan en nombre\
    \ de una tarea de v\xEDctima diferente (usando el mecanismo fpu_fpregs_owner_ctx)\
    \ y, en teor\xEDa, XRSTOR podr\xEDa fallar pero modificar los registros. Si esto\
    \ sucede, entonces hay una ventana en la que __fpu__restore_sig() podr\xEDa programar\
    \ la salida y la tarea de la v\xEDctima podr\xEDa volver a programarse sin recargar\
    \ sus propios registros FPU. Esto resultar\xEDa en parte del estado de la FPU\
    \ en el que __fpu__restore_sig() intentaba cargar una filtraci\xF3n en el estado\
    \ visible para el usuario de la tarea de la v\xEDctima. Invalide los registros\
    \ FPU preservados en caso de falla de XRSTOR para evitar que esta situaci\xF3\
    n corrompa cualquier estado. [1] Los lectores frecuentes de las listas de erratas\
    \ podr\xEDan imaginar \"condiciones microarquitect\xF3nicas complejas\"."
id: CVE-2021-47226
lastModified: '2024-05-21T16:54:26.047'
metrics: {}
published: '2024-05-21T15:15:11.823'
references:
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/002665dcba4bbec8c82f0aeb4bd3f44334ed2c14
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/a7748e021b9fb7739e3cb88449296539de0b6817
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/d8778e393afa421f1f117471144f8ce6deb6953a
sourceIdentifier: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
vulnStatus: Awaiting Analysis
