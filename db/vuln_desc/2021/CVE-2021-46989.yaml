descriptions:
- lang: en
  value: 'In the Linux kernel, the following vulnerability has been resolved:


    hfsplus: prevent corruption in shrinking truncate


    I believe there are some issues introduced by commit 31651c607151

    ("hfsplus: avoid deadlock on file truncation")


    HFS+ has extent records which always contains 8 extents.  In case the

    first extent record in catalog file gets full, new ones are allocated from

    extents overflow file.


    In case shrinking truncate happens to middle of an extent record which

    locates in extents overflow file, the logic in hfsplus_file_truncate() was

    changed so that call to hfs_brec_remove() is not guarded any more.


    Right action would be just freeing the extents that exceed the new size

    inside extent record by calling hfsplus_free_extents(), and then check if

    the whole extent record should be removed.  However since the guard

    (blk_cnt > start) is now after the call to hfs_brec_remove(), this has

    unfortunate effect that the last matching extent record is removed

    unconditionally.


    To reproduce this issue, create a file which has at least 10 extents, and

    then perform shrinking truncate into middle of the last extent record, so

    that the number of remaining extents is not under or divisible by 8.  This

    causes the last extent record (8 extents) to be removed totally instead of

    truncating into middle of it.  Thus this causes corruption, and lost data.


    Fix for this is simply checking if the new truncated end is below the

    start of this extent record, making it safe to remove the full extent

    record.  However call to hfs_brec_remove() can''t be moved to it''s previous

    place since we''re dropping ->tree_lock and it can cause a race condition

    and the cached info being invalidated possibly corrupting the node data.


    Another issue is related to this one.  When entering into the block

    (blk_cnt > start) we are not holding the ->tree_lock.  We break out from

    the loop not holding the lock, but hfs_find_exit() does unlock it.  Not

    sure if it''s possible for someone else to take the lock under our feet,

    but it can cause hard to debug errors and premature unlocking.  Even if

    there''s no real risk of it, the locking should still always be kept in

    balance.  Thus taking the lock now just before the check.'
- lang: es
  value: "En el kernel de Linux, se resolvi\xF3 la siguiente vulnerabilidad: hfsplus:\
    \ evita la corrupci\xF3n al reducir y truncar Creo que hay algunos problemas introducidos\
    \ por el commit 31651c607151 (\"hfsplus: evita el punto muerto en el truncamiento\
    \ de archivos\") HFS+ tiene registros de extensi\xF3n que siempre contienen 8\
    \ extensiones. En caso de que el primer registro de extensi\xF3n en el archivo\
    \ de cat\xE1logo se llene, se asignan nuevos registros desde el archivo de desbordamiento\
    \ de extensiones. En caso de que se produzca un truncamiento reducido en la mitad\
    \ de un registro de extensi\xF3n que se ubica en un archivo de desbordamiento\
    \ de extensiones, la l\xF3gica en hfsplus_file_truncate() se cambi\xF3 para que\
    \ la llamada a hfs_brec_remove() ya no est\xE9 protegida. La acci\xF3n correcta\
    \ ser\xEDa simplemente liberar las extensiones que exceden el nuevo tama\xF1o\
    \ dentro del registro de extensi\xF3n llamando a hfsplus_free_extents() y luego\
    \ verificar si se debe eliminar todo el registro de extensi\xF3n. Sin embargo,\
    \ dado que la guardia (blk_cnt &gt; start) est\xE1 ahora despu\xE9s de la llamada\
    \ a hfs_brec_remove(), esto tiene el efecto desafortunado de que el \xFAltimo\
    \ registro de extensi\xF3n coincidente se elimina incondicionalmente. Para reproducir\
    \ este problema, cree un archivo que tenga al menos 10 extensiones y luego realice\
    \ un truncamiento reducido hasta la mitad del \xFAltimo registro de extensi\xF3\
    n, de modo que el n\xFAmero de extensiones restantes no sea menor o divisible\
    \ por 8. Esto hace que el \xFAltimo registro de extensi\xF3n ( 8 extensiones)\
    \ para eliminarse por completo en lugar de truncarse a la mitad. Por tanto, esto\
    \ provoca corrupci\xF3n y p\xE9rdida de datos. La soluci\xF3n para esto es simplemente\
    \ verificar si el nuevo final truncado est\xE1 debajo del inicio de este registro\
    \ de extensi\xF3n, lo que hace que sea seguro eliminar el registro de extensi\xF3\
    n completo. Sin embargo, la llamada a hfs_brec_remove() no se puede mover a su\
    \ lugar anterior ya que estamos eliminando -&gt;tree_lock y puede provocar una\
    \ condici\xF3n de ejecuci\xF3n y la invalidaci\xF3n de la informaci\xF3n almacenada\
    \ en cach\xE9, posiblemente corrompiendo los datos del nodo. Otro tema est\xE1\
    \ relacionado con \xE9ste. Al ingresar al bloque (blk_cnt &gt; start) no mantenemos\
    \ -&gt;tree_lock. Salimos del bucle sin mantener el bloqueo, pero hfs_find_exit()\
    \ lo desbloquea. No estoy seguro de si es posible que otra persona tome el bloqueo\
    \ bajo nuestros pies, pero puede causar errores dif\xEDciles de depurar y desbloqueo\
    \ prematuro. Aunque no exista ning\xFAn riesgo real, el bloqueo siempre debe mantenerse\
    \ en equilibrio. Tomando as\xED el candado ahora justo antes del control."
id: CVE-2021-46989
lastModified: '2024-02-28T14:06:45.783'
metrics: {}
published: '2024-02-28T09:15:37.687'
references:
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/52dde855663e5db824af51db39b5757d2ef3e28a
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/97314e45aa1223a42d60256a62c5d9af54baf446
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/adbd8a2a8cc05d9e501f93e5c95c59307874cc99
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/c3187cf32216313fb316084efac4dab3a8459b1d
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/c451a6bafb5f422197d31536f82116aed132b72c
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/c477f62db1a0c0ecaa60a29713006ceeeb04b685
sourceIdentifier: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
vulnStatus: Awaiting Analysis
