cveTags: []
descriptions:
- lang: en
  value: 'In the Linux kernel, the following vulnerability has been resolved:


    net: dsa: lantiq_gswip: don''t use devres for mdiobus


    As explained in commits:

    74b6d7d13307 ("net: dsa: realtek: register the MDIO bus under devres")

    5135e96a3dd2 ("net: dsa: don''t allocate the slave_mii_bus using devres")


    mdiobus_free() will panic when called from devm_mdiobus_free() <-

    devres_release_all() <- __device_release_driver(), and that mdiobus was

    not previously unregistered.


    The GSWIP switch is a platform device, so the initial set of constraints

    that I thought would cause this (I2C or SPI buses which call ->remove on

    ->shutdown) do not apply. But there is one more which applies here.


    If the DSA master itself is on a bus that calls ->remove from ->shutdown

    (like dpaa2-eth, which is on the fsl-mc bus), there is a device link

    between the switch and the DSA master, and device_links_unbind_consumers()

    will unbind the GSWIP switch driver on shutdown.


    So the same treatment must be applied to all DSA switch drivers, which

    is: either use devres for both the mdiobus allocation and registration,

    or don''t use devres at all.


    The gswip driver has the code structure in place for orderly mdiobus

    removal, so just replace devm_mdiobus_alloc() with the non-devres

    variant, and add manual free where necessary, to ensure that we don''t

    let devres free a still-registered bus.'
- lang: es
  value: "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: net:\
    \ dsa: lantiq_gswip: no use devres para mdiobus Como se explica en los commits:\
    \ 74b6d7d13307 (\"net: dsa: realtek: registre el bus MDIO en devres\") 5135e96a3dd2\
    \ (\" net: dsa: no asigne el esclavo_mii_bus usando devres\") mdiobus_free() entrar\xE1\
    \ en p\xE1nico cuando se llame desde devm_mdiobus_free() &lt;- devres_release_all()\
    \ &lt;- __device_release_driver(), y ese mdiobus no fue anulado previamente. El\
    \ conmutador GSWIP es un dispositivo de plataforma, por lo que el conjunto inicial\
    \ de restricciones que pens\xE9 que causar\xEDa esto (buses I2C o SPI que llaman\
    \ -&gt;eliminar activado -&gt;apagar) no se aplican. Pero hay algo m\xE1s que\
    \ se aplica aqu\xED. Si el maestro DSA est\xE1 en un bus que llama -&gt;remove\
    \ from -&gt;shutdown (como dpaa2-eth, que est\xE1 en el bus fsl-mc), hay un enlace\
    \ de dispositivo entre el conmutador y el maestro DSA, y device_links_unbind_consumers(\
    \ ) desvincular\xE1 el controlador del conmutador GSWIP al apagar. Por lo tanto,\
    \ se debe aplicar el mismo tratamiento a todos los controladores de conmutador\
    \ DSA, que es: usar devres tanto para la asignaci\xF3n como para el registro de\
    \ mdiobus, o no usar devres en absoluto. El controlador gswip tiene la estructura\
    \ de c\xF3digo implementada para la eliminaci\xF3n ordenada de mdiobus, as\xED\
    \ que simplemente reemplace devm_mdiobus_alloc() con la variante que no es devres\
    \ y agregue manual free cuando sea necesario, para garantizar que no permitamos\
    \ que devres libere un bus a\xFAn registrado."
id: CVE-2022-48812
lastModified: '2024-07-16T13:43:58.773'
metrics: {}
published: '2024-07-16T12:15:05.430'
references:
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/0d120dfb5d67edc5bcd1804e167dba2b30809afd
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/2443ba2fe396bdde187a2fdfa6a57375643ae93c
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/b5652bc50dde7b84e93dfb25479b64b817e377c1
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/e177d2e85ebcd3008c4b2abc293f4118e04eedef
sourceIdentifier: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
vulnStatus: Awaiting Analysis
