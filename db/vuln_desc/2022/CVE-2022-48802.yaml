cveTags: []
descriptions:
- lang: en
  value: "In the Linux kernel, the following vulnerability has been resolved:\n\n\
    fs/proc: task_mmu.c: don't read mapcount for migration entry\n\nThe syzbot reported\
    \ the below BUG:\n\n  kernel BUG at include/linux/page-flags.h:785!\n  invalid\
    \ opcode: 0000 [#1] PREEMPT SMP KASAN\n  CPU: 1 PID: 4392 Comm: syz-executor560\
    \ Not tainted 5.16.0-rc6-syzkaller #0\n  Hardware name: Google Google Compute\
    \ Engine/Google Compute Engine, BIOS Google 01/01/2011\n  RIP: 0010:PageDoubleMap\
    \ include/linux/page-flags.h:785 [inline]\n  RIP: 0010:__page_mapcount+0x2d2/0x350\
    \ mm/util.c:744\n  Call Trace:\n    page_mapcount include/linux/mm.h:837 [inline]\n\
    \    smaps_account+0x470/0xb10 fs/proc/task_mmu.c:466\n    smaps_pte_entry fs/proc/task_mmu.c:538\
    \ [inline]\n    smaps_pte_range+0x611/0x1250 fs/proc/task_mmu.c:601\n    walk_pmd_range\
    \ mm/pagewalk.c:128 [inline]\n    walk_pud_range mm/pagewalk.c:205 [inline]\n\
    \    walk_p4d_range mm/pagewalk.c:240 [inline]\n    walk_pgd_range mm/pagewalk.c:277\
    \ [inline]\n    __walk_page_range+0xe23/0x1ea0 mm/pagewalk.c:379\n    walk_page_vma+0x277/0x350\
    \ mm/pagewalk.c:530\n    smap_gather_stats.part.0+0x148/0x260 fs/proc/task_mmu.c:768\n\
    \    smap_gather_stats fs/proc/task_mmu.c:741 [inline]\n    show_smap+0xc6/0x440\
    \ fs/proc/task_mmu.c:822\n    seq_read_iter+0xbb0/0x1240 fs/seq_file.c:272\n \
    \   seq_read+0x3e0/0x5b0 fs/seq_file.c:162\n    vfs_read+0x1b5/0x600 fs/read_write.c:479\n\
    \    ksys_read+0x12d/0x250 fs/read_write.c:619\n    do_syscall_x64 arch/x86/entry/common.c:50\
    \ [inline]\n    do_syscall_64+0x35/0xb0 arch/x86/entry/common.c:80\n    entry_SYSCALL_64_after_hwframe+0x44/0xae\n\
    \nThe reproducer was trying to read /proc/$PID/smaps when calling\nMADV_FREE at\
    \ the mean time.  MADV_FREE may split THPs if it is called\nfor partial THP. \
    \ It may trigger the below race:\n\n           CPU A                         CPU\
    \ B\n           -----                         -----\n  smaps walk:           \
    \           MADV_FREE:\n  page_mapcount()\n    PageCompound()\n              \
    \                     split_huge_page()\n    page = compound_head(page)\n    PageDoubleMap(page)\n\
    \nWhen calling PageDoubleMap() this page is not a tail page of THP anymore\nso\
    \ the BUG is triggered.\n\nThis could be fixed by elevated refcount of the page\
    \ before calling\nmapcount, but that would prevent it from counting migration\
    \ entries, and\nit seems overkilling because the race just could happen when PMD\
    \ is\nsplit so all PTE entries of tail pages are actually migration entries,\n\
    and smaps_account() does treat migration entries as mapcount == 1 as\nKirill pointed\
    \ out.\n\nAdd a new parameter for smaps_account() to tell this entry is migration\n\
    entry then skip calling page_mapcount().  Don't skip getting mapcount\nfor device\
    \ private entries since they do track references with mapcount.\n\nPagemap also\
    \ has the similar issue although it was not reported.  Fixed\nit as well.\n\n\
    [shy828301@gmail.com: v4]\n  Link: https://lkml.kernel.org/r/20220203182641.824731-1-shy828301@gmail.com\n\
    [nathan@kernel.org: avoid unused variable warning in pagemap_pmd_range()]\n  Link:\
    \ https://lkml.kernel.org/r/20220207171049.1102239-1-nathan@kernel.org"
- lang: es
  value: "En el kernel de Linux, se resolvi\xF3 la siguiente vulnerabilidad: fs/proc:\
    \ task_mmu.c: no lea el recuento de mapas para la entrada de migraci\xF3n. El\
    \ syzbot inform\xF3 el siguiente ERROR: ERROR del kernel en include/linux/page-flags.h:785.\
    \ c\xF3digo de operaci\xF3n no v\xE1lido: 0000 [#1] PREEMPT SMP KASAN CPU: 1 PID:\
    \ 4392 Comm: syz-executor560 Not tainted 5.16.0-rc6-syzkaller #0 Nombre del hardware:\
    \ Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01 /2011\
    \ RIP: 0010:PageDoubleMap include/linux/page-flags.h:785 [en l\xEDnea] RIP: 0010:__page_mapcount+0x2d2/0x350\
    \ mm/util.c:744 Seguimiento de llamadas: page_mapcount include/linux/mm.h:837\
    \ [en l\xEDnea] smaps_account+0x470/0xb10 fs/proc/task_mmu.c:466 smaps_pte_entry\
    \ fs/proc/task_mmu.c:538 [en l\xEDnea] smaps_pte_range+0x611/0x1250 fs/proc/task_mmu.c:601\
    \ walk_pmd_range mm/pagewalk.c :128 [en l\xEDnea] walk_pud_range mm/pagewalk.c:205\
    \ [en l\xEDnea] walk_p4d_range mm/pagewalk.c:240 [en l\xEDnea] walk_pgd_range\
    \ mm/pagewalk.c:277 [en l\xEDnea] __walk_page_range+0xe23/0x1ea0 mm/pagewalk.c:379\
    \ walk_page_vma+0x277/0x350 mm/pagewalk.c:530 smap_gather_stats.part.0+0x148/0x260\
    \ fs/proc/task_mmu.c:768 smap_gather_stats fs/proc/task_mmu.c:741 [en l\xEDnea]\
    \ show_smap+0xc6/0x440 fs/ proc/task_mmu.c:822 seq_read_iter+0xbb0/0x1240 fs/seq_file.c:272\
    \ seq_read+0x3e0/0x5b0 fs/seq_file.c:162 vfs_read+0x1b5/0x600 fs/read_write.c:479\
    \ ksys_read+0x12d/0x250 f s/ read_write.c:619 do_syscall_x64 arch/x86/entry/common.c:50\
    \ [en l\xEDnea] do_syscall_64+0x35/0xb0 arch/x86/entry/common.c:80 Entry_SYSCALL_64_after_hwframe+0x44/0xae\
    \ El reproductor estaba intentando leer /proc/ $PID/smaps al llamar a MADV_FREE\
    \ mientras tanto. MADV_FREE puede dividir THP si se solicita para THP parcial.\
    \ Puede desencadenar la siguiente ejecuci\xF3n: CPU A CPU B ----- ----- smaps\
    \ walk: MADV_FREE: page_mapcount() PageCompound() split_huge_page() p\xE1gina\
    \ = composite_head(page) PageDoubleMap(page) Al llamar a PageDoubleMap() Esta\
    \ p\xE1gina ya no es una p\xE1gina final de THP, por lo que se activa el ERROR.\
    \ Esto podr\xEDa solucionarse mediante un recuento elevado de la p\xE1gina antes\
    \ de llamar a mapcount, pero eso evitar\xEDa que cuente las entradas de migraci\xF3\
    n, y parece excesivo porque la ejecuci\xF3n podr\xEDa ocurrir cuando PMD se divide,\
    \ por lo que todas las entradas PTE de las p\xE1ginas finales son en realidad\
    \ entradas de migraci\xF3n. y smaps_account() trata las entradas de migraci\xF3\
    n como mapcount == 1 como se\xF1al\xF3 Kirill. Agregue un nuevo par\xE1metro para\
    \ smaps_account() para indicar que esta entrada es una entrada de migraci\xF3\
    n y luego omita llamar a page_mapcount(). No deje de obtener mapcount para entradas\
    \ privadas de dispositivos, ya que rastrean referencias con mapcount. Pagemap\
    \ tambi\xE9n tiene un problema similar, aunque no se inform\xF3. Lo arregl\xE9\
    \ tambi\xE9n. [shy828301@gmail.com: v4] Enlace: https://lkml.kernel.org/r/20220203182641.824731-1-shy828301@gmail.com\
    \ [nathan@kernel.org: evitar advertencia de variable no utilizada en pagemap_pmd_range()]\
    \ Enlace: https://lkml.kernel.org/r/20220207171049.1102239-1-nathan@kernel.org"
id: CVE-2022-48802
lastModified: '2024-07-16T13:43:58.773'
metrics: {}
published: '2024-07-16T12:15:04.690'
references:
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/05d3f8045efa59457b323caf00bdb9273b7962fa
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/24d7275ce2791829953ed4e72f68277ceb2571c6
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/a8dd0cfa37792863b6c4bf9542975212a6715d49
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/db3f3636e4aed2cba3e4e7897a053323f7a62249
sourceIdentifier: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
vulnStatus: Awaiting Analysis
