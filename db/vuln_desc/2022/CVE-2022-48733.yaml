descriptions:
- lang: en
  value: "In the Linux kernel, the following vulnerability has been resolved:\n\n\
    btrfs: fix use-after-free after failure to create a snapshot\n\nAt ioctl.c:create_snapshot(),\
    \ we allocate a pending snapshot structure and\nthen attach it to the transaction's\
    \ list of pending snapshots. After that\nwe call btrfs_commit_transaction(), and\
    \ if that returns an error we jump\nto 'fail' label, where we kfree() the pending\
    \ snapshot structure. This can\nresult in a later use-after-free of the pending\
    \ snapshot:\n\n1) We allocated the pending snapshot and added it to the transaction's\n\
    \   list of pending snapshots;\n\n2) We call btrfs_commit_transaction(), and it\
    \ fails either at the first\n   call to btrfs_run_delayed_refs() or btrfs_start_dirty_block_groups().\n\
    \   In both cases, we don't abort the transaction and we release our\n   transaction\
    \ handle. We jump to the 'fail' label and free the pending\n   snapshot structure.\
    \ We return with the pending snapshot still in the\n   transaction's list;\n\n\
    3) Another task commits the transaction. This time there's no error at\n   all,\
    \ and then during the transaction commit it accesses a pointer\n   to the pending\
    \ snapshot structure that the snapshot creation task\n   has already freed, resulting\
    \ in a user-after-free.\n\nThis issue could actually be detected by smatch, which\
    \ produced the\nfollowing warning:\n\n  fs/btrfs/ioctl.c:843 create_snapshot()\
    \ warn: '&pending_snapshot->list' not removed from list\n\nSo fix this by not\
    \ having the snapshot creation ioctl directly add the\npending snapshot to the\
    \ transaction's list. Instead add the pending\nsnapshot to the transaction handle,\
    \ and then at btrfs_commit_transaction()\nwe add the snapshot to the list only\
    \ when we can guarantee that any error\nreturned after that point will result\
    \ in a transaction abort, in which\ncase the ioctl code can safely free the pending\
    \ snapshot and no one can\naccess it anymore."
- lang: es
  value: "En el kernel de Linux, se resolvi\xF3 la siguiente vulnerabilidad: btrfs:\
    \ corrige el use-after-free despu\xE9s de una falla al crear una instant\xE1nea\
    \ En ioctl.c:create_snapshot(), asignamos una estructura de instant\xE1nea pendiente\
    \ y luego la adjuntamos a la lista de transacciones de instant\xE1neas pendientes.\
    \ Despu\xE9s de eso, llamamos a btrfs_commit_transaction(), y si eso devuelve\
    \ un error, saltamos a la etiqueta 'falla', donde liberamos() la estructura de\
    \ instant\xE1nea pendiente. Esto puede resultar en un uso posterior despu\xE9\
    s de la liberaci\xF3n de la instant\xE1nea pendiente: 1) Asignamos la instant\xE1\
    nea pendiente y la agregamos a la lista de instant\xE1neas pendientes de la transacci\xF3\
    n; 2) Llamamos a btrfs_commit_transaction(), y falla en la primera llamada a btrfs_run_delayed_refs()\
    \ o btrfs_start_dirty_block_groups(). En ambos casos, no abortamos la transacci\xF3\
    n y liberamos nuestro identificador de transacci\xF3n. Saltamos a la etiqueta\
    \ 'fallo' y liberamos la estructura de instant\xE1nea pendiente. Regresamos con\
    \ la instant\xE1nea pendiente todav\xEDa en la lista de transacciones; 3) Otra\
    \ tarea confirma la transacci\xF3n. Esta vez no hay ning\xFAn error y luego, durante\
    \ la confirmaci\xF3n de la transacci\xF3n, accede a un puntero a la estructura\
    \ de instant\xE1nea pendiente que la tarea de creaci\xF3n de instant\xE1nea ya\
    \ ha liberado, lo que resulta en una liberaci\xF3n de usuario. En realidad, este\
    \ problema podr\xEDa ser detectado por smatch, que produjo la siguiente advertencia:\
    \ fs/btrfs/ioctl.c:843 create_snapshot() advertencia: '&amp;pending_snapshot-&gt;list'\
    \ no se elimina de la lista. As\xED que solucione este problema al no tener el\
    \ ioctl de creaci\xF3n de instant\xE1neas directamente agregue la instant\xE1\
    nea pendiente a la lista de transacciones. En su lugar, agregue la instant\xE1\
    nea pendiente al identificador de la transacci\xF3n, y luego en btrfs_commit_transaction()\
    \ agregamos la instant\xE1nea a la lista solo cuando podamos garantizar que cualquier\
    \ error devuelto despu\xE9s de ese punto resultar\xE1 en la cancelaci\xF3n de\
    \ la transacci\xF3n, en cuyo caso el c\xF3digo ioctl puede Libera la instant\xE1\
    nea pendiente y ya nadie podr\xE1 acceder a ella."
id: CVE-2022-48733
lastModified: '2024-06-20T12:43:25.663'
metrics: {}
published: '2024-06-20T12:15:11.700'
references:
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/28b21c558a3753171097193b6f6602a94169093a
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/9372fa1d73da5f1673921e365d0cd2c27ec7adc2
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/a7b717fa15165d3d9245614680bebc48a52ac05d
sourceIdentifier: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
vulnStatus: Awaiting Analysis
