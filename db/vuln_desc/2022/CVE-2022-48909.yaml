cveTags: []
descriptions:
- lang: en
  value: "In the Linux kernel, the following vulnerability has been resolved:\n\n\
    net/smc: fix connection leak\n\nThere's a potential leak issue under following\
    \ execution sequence :\n\nsmc_release  \t\t\t\tsmc_connect_work\nif (sk->sk_state\
    \ == SMC_INIT)\n\t\t\t\t\tsend_clc_confirim\n\ttcp_abort();\n\t\t\t\t\t...\n\t\
    \t\t\t\tsk.sk_state = SMC_ACTIVE\nsmc_close_active\nswitch(sk->sk_state) {\n...\n\
    case SMC_ACTIVE:\n\tsmc_close_final()\n\t// then wait peer closed\n\nUnfortunately,\
    \ tcp_abort() may discard CLC CONFIRM messages that are\nstill in the tcp send\
    \ buffer, in which case our connection token cannot\nbe delivered to the server\
    \ side, which means that we cannot get a\npassive close message at all. Therefore,\
    \ it is impossible for the to be\ndisconnected at all.\n\nThis patch tries a very\
    \ simple way to avoid this issue, once the state\nhas changed to SMC_ACTIVE after\
    \ tcp_abort(), we can actively abort the\nsmc connection, considering that the\
    \ state is SMC_INIT before\ntcp_abort(), abandoning the complete disconnection\
    \ process should not\ncause too much problem.\n\nIn fact, this problem may exist\
    \ as long as the CLC CONFIRM message is\nnot received by the server. Whether a\
    \ timer should be added after\nsmc_close_final() needs to be discussed in the\
    \ future. But even so, this\npatch provides a faster release for connection in\
    \ above case, it should\nalso be valuable."
- lang: es
  value: "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: net/smc:\
    \ reparar fuga de conexi\xF3n Hay un posible problema de fuga en la siguiente\
    \ secuencia de ejecuci\xF3n: smc_release smc_connect_work if (sk-&gt;sk_state\
    \ == SMC_INIT) send_clc_confirim tcp_abort(); ... sk.sk_state = SMC_ACTIVE smc_close_active\
    \ switch(sk-&gt;sk_state) { ... case SMC_ACTIVE: smc_close_final() // luego espera\
    \ el par cerrado Desafortunadamente, tcp_abort() puede descartar los mensajes\
    \ CLC CONFIRM que todav\xEDa est\xE1n en el b\xFAfer de env\xEDo tcp , en cuyo\
    \ caso nuestro token de conexi\xF3n no se puede entregar al lado del servidor,\
    \ lo que significa que no podemos recibir ning\xFAn mensaje de cierre pasivo.\
    \ Por lo tanto, es imposible desconectarlo en absoluto. Este parche intenta una\
    \ forma muy sencilla de evitar este problema, una vez que el estado ha cambiado\
    \ a SMC_ACTIVE despu\xE9s de tcp_abort(), podemos cancelar activamente la conexi\xF3\
    n smc, considerando que el estado es SMC_INIT antes de tcp_abort(), abandonar\
    \ el proceso de desconexi\xF3n completo no deber\xEDa causar demasiado problema.\
    \ De hecho, este problema puede existir siempre y cuando el servidor no reciba\
    \ el mensaje CONFIRM CLC. En el futuro se deber\xE1 discutir si se debe agregar\
    \ un temporizador despu\xE9s de smc_close_final(). Pero aun as\xED, este parche\
    \ proporciona una liberaci\xF3n m\xE1s r\xE1pida para la conexi\xF3n. En el caso\
    \ anterior, tambi\xE9n deber\xEDa ser valioso."
id: CVE-2022-48909
lastModified: '2024-08-22T12:48:02.790'
metrics: {}
published: '2024-08-22T02:15:05.333'
references:
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/2e8d465b83db307f04ad265848f8ab3f78f6918f
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/80895b6f9154fb22d36fab311ccbb75503a2c87b
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/9f1c50cf39167ff71dc5953a3234f3f6eeb8fcb5
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/e98d46ccfa84b35a9e4b1ccdd83961b41a5d7ce5
sourceIdentifier: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
vulnStatus: Undergoing Analysis
