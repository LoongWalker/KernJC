descriptions:
- lang: en
  value: 'In the Linux kernel, the following vulnerability has been resolved:


    KVM: arm64: Avoid consuming a stale esr value when SError occur


    When any exception other than an IRQ occurs, the CPU updates the ESR_EL2

    register with the exception syndrome. An SError may also become pending,

    and will be synchronised by KVM. KVM notes the exception type, and whether

    an SError was synchronised in exit_code.


    When an exception other than an IRQ occurs, fixup_guest_exit() updates

    vcpu->arch.fault.esr_el2 from the hardware register. When an SError was

    synchronised, the vcpu esr value is used to determine if the exception

    was due to an HVC. If so, ELR_EL2 is moved back one instruction. This

    is so that KVM can process the SError first, and re-execute the HVC if

    the guest survives the SError.


    But if an IRQ synchronises an SError, the vcpu''s esr value is stale.

    If the previous non-IRQ exception was an HVC, KVM will corrupt ELR_EL2,

    causing an unrelated guest instruction to be executed twice.


    Check ARM_EXCEPTION_CODE() before messing with ELR_EL2, IRQs don''t

    update this register so don''t need to check.'
- lang: es
  value: "En el kernel de Linux, se resolvi\xF3 la siguiente vulnerabilidad: KVM:\
    \ arm64: Evite consumir un valor esr obsoleto cuando ocurre un SError Cuando ocurre\
    \ cualquier excepci\xF3n que no sea una IRQ, la CPU actualiza el registro ESR_EL2\
    \ con el s\xEDndrome de excepci\xF3n. Un SError tambi\xE9n puede quedar pendiente\
    \ y KVM lo sincronizar\xE1. KVM anota el tipo de excepci\xF3n y si se sincroniz\xF3\
    \ un SError en exit_code. Cuando ocurre una excepci\xF3n distinta a una IRQ, fixup_guest_exit()\
    \ actualiza vcpu-&gt;arch.fault.esr_el2 desde el registro de hardware. Cuando\
    \ se sincroniza un SError, el valor de vcpu esr se utiliza para determinar si\
    \ la excepci\xF3n se debi\xF3 a un HVC. Si es as\xED, ELR_EL2 retrocede una instrucci\xF3\
    n. Esto es para que KVM pueda procesar el SError primero y volver a ejecutar el\
    \ HVC si el invitado sobrevive al SError. Pero si una IRQ sincroniza un SError,\
    \ el valor esr de la vcpu est\xE1 obsoleto. Si la excepci\xF3n anterior no IRQ\
    \ era un HVC, KVM da\xF1ar\xE1 ELR_EL2, lo que provocar\xE1 que se ejecute dos\
    \ veces una instrucci\xF3n invitada no relacionada. Verifique ARM_EXCEPTION_CODE()\
    \ antes de jugar con ELR_EL2, las IRQ no actualizan este registro, por lo que\
    \ no es necesario verificarlo."
id: CVE-2022-48727
lastModified: '2024-06-20T12:43:25.663'
metrics: {}
published: '2024-06-20T12:15:11.167'
references:
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/1c71dbc8a179d99dd9bb7e7fc1888db613cf85de
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/57e2986c3b25092691a6e3d6ee9168caf8978932
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/e1e852746997500f1873f60b954da5f02cc2dba3
sourceIdentifier: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
vulnStatus: Awaiting Analysis
