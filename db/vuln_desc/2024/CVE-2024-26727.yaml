cveTags: []
descriptions:
- lang: en
  value: "In the Linux kernel, the following vulnerability has been resolved:\n\n\
    btrfs: do not ASSERT() if the newly created subvolume already got read\n\n[BUG]\n\
    There is a syzbot crash, triggered by the ASSERT() during subvolume\ncreation:\n\
    \n assertion failed: !anon_dev, in fs/btrfs/disk-io.c:1319\n ------------[ cut\
    \ here ]------------\n kernel BUG at fs/btrfs/disk-io.c:1319!\n invalid opcode:\
    \ 0000 [#1] PREEMPT SMP KASAN\n RIP: 0010:btrfs_get_root_ref.part.0+0x9aa/0xa60\n\
    \  <TASK>\n  btrfs_get_new_fs_root+0xd3/0xf0\n  create_subvol+0xd02/0x1650\n \
    \ btrfs_mksubvol+0xe95/0x12b0\n  __btrfs_ioctl_snap_create+0x2f9/0x4f0\n  btrfs_ioctl_snap_create+0x16b/0x200\n\
    \  btrfs_ioctl+0x35f0/0x5cf0\n  __x64_sys_ioctl+0x19d/0x210\n  do_syscall_64+0x3f/0xe0\n\
    \  entry_SYSCALL_64_after_hwframe+0x63/0x6b\n ---[ end trace 0000000000000000\
    \ ]---\n\n[CAUSE]\nDuring create_subvol(), after inserting root item for the newly\
    \ created\nsubvolume, we would trigger btrfs_get_new_fs_root() to get the\nbtrfs_root\
    \ of that subvolume.\n\nThe idea here is, we have preallocated an anonymous device\
    \ number for\nthe subvolume, thus we can assign it to the new subvolume.\n\nBut\
    \ there is really nothing preventing things like backref walk to read\nthe new\
    \ subvolume.\nIf that happens before we call btrfs_get_new_fs_root(), the subvolume\n\
    would be read out, with a new anonymous device number assigned already.\n\nIn\
    \ that case, we would trigger ASSERT(), as we really expect no one to\nread out\
    \ that subvolume (which is not yet accessible from the fs).\nBut things like backref\
    \ walk is still possible to trigger the read on\nthe subvolume.\n\nThus our assumption\
    \ on the ASSERT() is not correct in the first place.\n\n[FIX]\nFix it by removing\
    \ the ASSERT(), and just free the @anon_dev, reset it\nto 0, and continue.\n\n\
    If the subvolume tree is read out by something else, it should have\nalready get\
    \ a new anon_dev assigned thus we only need to free the\npreallocated one."
- lang: es
  value: "En el kernel de Linux, se resolvi\xF3 la siguiente vulnerabilidad: btrfs:\
    \ no haga ASSERT() si el subvolumen reci\xE9n creado ya se ley\xF3 [ERROR] Hay\
    \ un bloqueo del syzbot, provocado por ASSERT() durante la creaci\xF3n del subvolumen:\
    \ la aserci\xF3n fall\xF3: ! anon_dev, en fs/btrfs/disk-io.c:1319 ------------[\
    \ cortar aqu\xED ]------------ ERROR del kernel en fs/btrfs/disk -io.c:1319! c\xF3\
    digo de operaci\xF3n no v\xE1lido: 0000 [#1] PREEMPT SMP KASAN RIP: 0010:btrfs_get_root_ref.part.0+0x9aa/0xa60\
    \  btrfs_get_new_fs_root+0xd3/0xf0 create_subvol+0xd02/0x1650 btrfs_mksubvol+0xe95/0x12b0\
    \ __ btrfs_ioctl_snap_create+0x2f9/0x4f0 btrfs_ioctl_snap_create+0x16b /0x200\
    \ btrfs_ioctl+0x35f0/0x5cf0 __x64_sys_ioctl+0x19d/0x210 do_syscall_64+0x3f/0xe0\
    \ Entry_SYSCALL_64_after_hwframe+0x63/0x6b ---[ end trace 0000000000000000 ]---\
    \ [CA USO] Durante create_subvol(), despu\xE9s de insertar el elemento ra\xED\
    z para el subvolumen reci\xE9n creado , activar\xEDamos btrfs_get_new_fs_root()\
    \ para obtener el btrfs_root de ese subvolumen. La idea aqu\xED es que hemos preasignado\
    \ un n\xFAmero de dispositivo an\xF3nimo para el subvolumen, por lo que podemos\
    \ asignarlo al nuevo subvolumen. Pero realmente no hay nada que impida que cosas\
    \ como backref caminen para leer el nuevo subvolumen. Si eso sucede antes de que\
    \ llamemos a btrfs_get_new_fs_root(), se leer\xE1 el subvolumen y ya se habr\xE1\
    \ asignado un nuevo n\xFAmero de dispositivo an\xF3nimo. En ese caso, activar\xED\
    amos ASSERT(), ya que realmente esperamos que nadie lea ese subvolumen (al que\
    \ a\xFAn no se puede acceder desde fs). Pero a\xFAn es posible realizar cosas\
    \ como el recorrido de referencia atr\xE1s para activar la lectura en el subvolumen.\
    \ Por lo tanto, nuestra suposici\xF3n sobre ASSERT() no es correcta en primer\
    \ lugar. [FIX] Arr\xE9glelo eliminando ASSERT() y simplemente libere @anon_dev,\
    \ restablezcalo a 0 y contin\xFAe. Si otra cosa lee el \xE1rbol de subvolumen,\
    \ ya deber\xEDa tener asignado un nuevo anon_dev, por lo que solo necesitamos\
    \ liberar el preasignado."
id: CVE-2024-26727
lastModified: '2024-06-25T21:15:58.400'
metrics: {}
published: '2024-04-03T15:15:54.367'
references:
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/3f5d47eb163bceb1b9e613c9003bae5fefc0046f
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/5a172344bfdabb46458e03708735d7b1a918c468
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/66b317a2fc45b2ef66527ee3f8fa08fb5beab88d
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/833775656d447c545133a744a0ed1e189ce61430
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/e03ee2fe873eb68c1f9ba5112fee70303ebf9dfb
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/e31546b0f34af21738c4ceac47d662c00ee6382f
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html
sourceIdentifier: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
vulnStatus: Awaiting Analysis
