cveTags: []
descriptions:
- lang: en
  value: 'In the Linux kernel, the following vulnerability has been resolved:


    KVM: x86: Mark target gfn of emulated atomic instruction as dirty


    When emulating an atomic access on behalf of the guest, mark the target

    gfn dirty if the CMPXCHG by KVM is attempted and doesn''t fault.  This

    fixes a bug where KVM effectively corrupts guest memory during live

    migration by writing to guest memory without informing userspace that the

    page is dirty.


    Marking the page dirty got unintentionally dropped when KVM''s emulated

    CMPXCHG was converted to do a user access.  Before that, KVM explicitly

    mapped the guest page into kernel memory, and marked the page dirty during

    the unmap phase.


    Mark the page dirty even if the CMPXCHG fails, as the old data is written

    back on failure, i.e. the page is still written.  The value written is

    guaranteed to be the same because the operation is atomic, but KVM''s ABI

    is that all writes are dirty logged regardless of the value written.  And

    more importantly, that''s what KVM did before the buggy commit.


    Huge kudos to the folks on the Cc list (and many others), who did all the

    actual work of triaging and debugging.


    base-commit: 6769ea8da8a93ed4630f1ce64df6aafcaabfce64'
- lang: es
  value: "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: KVM:\
    \ x86: marcar el gfn de destino de la instrucci\xF3n at\xF3mica emulada como sucia\
    \ Al emular un acceso at\xF3mico en nombre del invitado, marque el gfn de destino\
    \ como sucio si se intenta realizar el CMPXCHG por KVM y no falla. Esto corrige\
    \ un error por el cual KVM corrompe efectivamente la memoria del invitado durante\
    \ la migraci\xF3n en vivo al escribir en la memoria del invitado sin informar\
    \ al espacio de usuario que la p\xE1gina est\xE1 sucia. Marcar la p\xE1gina como\
    \ sucia se elimin\xF3 involuntariamente cuando el CMPXCHG emulado de KVM se convirti\xF3\
    \ para realizar un acceso de usuario. Antes de eso, KVM asignaba expl\xEDcitamente\
    \ la p\xE1gina invitada a la memoria del kernel y marcaba la p\xE1gina como sucia\
    \ durante la fase de desasignaci\xF3n. Marque la p\xE1gina como sucia incluso\
    \ si CMPXCHG falla, ya que los datos antiguos se vuelven a escribir en caso de\
    \ fallo, es decir, la p\xE1gina a\xFAn est\xE1 escrita. Se garantiza que el valor\
    \ escrito ser\xE1 el mismo porque la operaci\xF3n es at\xF3mica, pero la ABI de\
    \ KVM es que todas las escrituras se registran de forma sucia independientemente\
    \ del valor escrito. Y lo que es m\xE1s importante, eso es lo que hizo KVM antes\
    \ de la confirmaci\xF3n del error. Felicitaciones enormes a las personas en la\
    \ lista Cc (y a muchos otros), que hicieron todo el trabajo de clasificaci\xF3\
    n y depuraci\xF3n. confirmaci\xF3n base: 6769ea8da8a93ed4630f1ce64df6aafcaabfce64"
id: CVE-2024-35804
lastModified: '2024-05-17T18:35:35.070'
metrics: {}
published: '2024-05-17T14:15:13.550'
references:
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/225d587a073584946c05c9b7651d637bd45c0c71
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/726374dde5d608b15b9756bd52b6fc283fda7a06
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/910c57dfa4d113aae6571c2a8b9ae8c430975902
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/9d1b22e573a3789ed1f32033ee709106993ba551
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/a9bd6bb6f02bf7132c1ab192ba62bbfa52df7d66
sourceIdentifier: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
vulnStatus: Awaiting Analysis
