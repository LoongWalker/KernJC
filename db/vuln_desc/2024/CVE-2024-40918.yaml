cveTags: []
descriptions:
- lang: en
  value: 'In the Linux kernel, the following vulnerability has been resolved:


    parisc: Try to fix random segmentation faults in package builds


    PA-RISC systems with PA8800 and PA8900 processors have had problems

    with random segmentation faults for many years.  Systems with earlier

    processors are much more stable.


    Systems with PA8800 and PA8900 processors have a large L2 cache which

    needs per page flushing for decent performance when a large range is

    flushed. The combined cache in these systems is also more sensitive to

    non-equivalent aliases than the caches in earlier systems.


    The majority of random segmentation faults that I have looked at

    appear to be memory corruption in memory allocated using mmap and

    malloc.


    My first attempt at fixing the random faults didn''t work. On

    reviewing the cache code, I realized that there were two issues

    which the existing code didn''t handle correctly. Both relate

    to cache move-in. Another issue is that the present bit in PTEs

    is racy.


    1) PA-RISC caches have a mind of their own and they can speculatively

    load data and instructions for a page as long as there is a entry in

    the TLB for the page which allows move-in. TLBs are local to each

    CPU. Thus, the TLB entry for a page must be purged before flushing

    the page. This is particularly important on SMP systems.


    In some of the flush routines, the flush routine would be called

    and then the TLB entry would be purged. This was because the flush

    routine needed the TLB entry to do the flush.


    2) My initial approach to trying the fix the random faults was to

    try and use flush_cache_page_if_present for all flush operations.

    This actually made things worse and led to a couple of hardware

    lockups. It finally dawned on me that some lines weren''t being

    flushed because the pte check code was racy. This resulted in

    random inequivalent mappings to physical pages.


    The __flush_cache_page tmpalias flush sets up its own TLB entry

    and it doesn''t need the existing TLB entry. As long as we can find

    the pte pointer for the vm page, we can get the pfn and physical

    address of the page. We can also purge the TLB entry for the page

    before doing the flush. Further, __flush_cache_page uses a special

    TLB entry that inhibits cache move-in.


    When switching page mappings, we need to ensure that lines are

    removed from the cache.  It is not sufficient to just flush the

    lines to memory as they may come back.


    This made it clear that we needed to implement all the required

    flush operations using tmpalias routines. This includes flushes

    for user and kernel pages.


    After modifying the code to use tmpalias flushes, it became clear

    that the random segmentation faults were not fully resolved. The

    frequency of faults was worse on systems with a 64 MB L2 (PA8900)

    and systems with more CPUs (rp4440).


    The warning that I added to flush_cache_page_if_present to detect

    pages that couldn''t be flushed triggered frequently on some systems.


    Helge and I looked at the pages that couldn''t be flushed and found

    that the PTE was either cleared or for a swap page. Ignoring pages

    that were swapped out seemed okay but pages with cleared PTEs seemed

    problematic.


    I looked at routines related to pte_clear and noticed ptep_clear_flush.

    The default implementation just flushes the TLB entry. However, it was

    obvious that on parisc we need to flush the cache page as well. If

    we don''t flush the cache page, stale lines will be left in the cache

    and cause random corruption. Once a PTE is cleared, there is no way

    to find the physical address associated with the PTE and flush the

    associated page at a later time.


    I implemented an updated change with a parisc specific version of

    ptep_clear_flush. It fixed the random data corruption on Helge''s rp4440

    and rp3440, as well as on my c8000.


    At this point, I realized that I could restore the code where we only

    flush in flush_cache_page_if_present if the page has been accessed.

    However, for this, we also need to flush the cache when the accessed

    bit is cleared in

    ---truncated---'
- lang: es
  value: "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: parisc:\
    \ intenta corregir fallas de segmentaci\xF3n aleatoria en compilaciones de paquetes.\
    \ Los sistemas PA-RISC con procesadores PA8800 y PA8900 han tenido problemas con\
    \ fallas de segmentaci\xF3n aleatoria durante muchos a\xF1os. Los sistemas con\
    \ procesadores anteriores son mucho m\xE1s estables. Los sistemas con procesadores\
    \ PA8800 y PA8900 tienen una gran cach\xE9 L2 que necesita un vaciado por p\xE1\
    gina para un rendimiento decente cuando se vac\xEDa un rango grande. La cach\xE9\
    \ combinada en estos sistemas tambi\xE9n es m\xE1s sensible a alias no equivalentes\
    \ que las cach\xE9s de sistemas anteriores. La mayor\xEDa de los fallos de segmentaci\xF3\
    n aleatoria que he observado parecen ser da\xF1os en la memoria asignada mediante\
    \ mmap y malloc. Mi primer intento de solucionar los fallos aleatorios no funcion\xF3\
    . Al revisar el c\xF3digo de cach\xE9, me di cuenta de que hab\xEDa dos problemas\
    \ que el c\xF3digo existente no manejaba correctamente. Ambos se relacionan con\
    \ la entrada de cach\xE9. Otro problema es que la actualidad en las PTE es picante.\
    \ 1) Los cach\xE9s PA-RISC tienen mente propia y pueden cargar especulativamente\
    \ datos e instrucciones para una p\xE1gina siempre que haya una entrada en el\
    \ TLB para la p\xE1gina que permita la entrada. Los TLB son locales para cada\
    \ CPU. Por lo tanto, la entrada TLB de una p\xE1gina debe eliminarse antes de\
    \ eliminarla. Esto es particularmente importante en los sistemas SMP. En algunas\
    \ de las rutinas de vaciado, se llamar\xEDa a la rutina de vaciado y luego se\
    \ purgar\xEDa la entrada TLB. Esto se deb\xEDa a que la rutina de lavado necesitaba\
    \ la entrada TLB para realizar el lavado. 2) Mi enfoque inicial para intentar\
    \ solucionar las fallas aleatorias fue intentar usar Flush_cache_page_if_present\
    \ para todas las operaciones de descarga. En realidad, esto empeor\xF3 las cosas\
    \ y provoc\xF3 un par de bloqueos de hardware. Finalmente me di cuenta de que\
    \ algunas l\xEDneas no se estaban borrando porque el c\xF3digo de verificaci\xF3\
    n del pte era picante. Esto result\xF3 en asignaciones aleatorias no equivalentes\
    \ a p\xE1ginas f\xEDsicas. La descarga tmpalias __flush_cache_page configura su\
    \ propia entrada TLB y no necesita la entrada TLB existente. Siempre que podamos\
    \ encontrar el puntero pte de la p\xE1gina vm, podemos obtener el pfn y la direcci\xF3\
    n f\xEDsica de la p\xE1gina. Tambi\xE9n podemos purgar la entrada TLB de la p\xE1\
    gina antes de realizar el vaciado. Adem\xE1s, __flush_cache_page utiliza una entrada\
    \ TLB especial que inhibe la entrada de cach\xE9. Al cambiar las asignaciones\
    \ de p\xE1ginas, debemos asegurarnos de que las l\xEDneas se eliminen del cach\xE9\
    . No es suficiente simplemente borrar las l\xEDneas de la memoria, ya que pueden\
    \ volver. Esto dej\xF3 en claro que necesit\xE1bamos implementar todas las operaciones\
    \ de vaciado necesarias utilizando rutinas tmpalias. Esto incluye vaciados para\
    \ p\xE1ginas de usuario y de kernel. Despu\xE9s de modificar el c\xF3digo para\
    \ usar tmpalias vaciados, qued\xF3 claro que los errores de segmentaci\xF3n aleatoria\
    \ no se resolvieron por completo. La frecuencia de fallas fue peor en sistemas\
    \ con 64 MB L2 (PA8900) y sistemas con m\xE1s CPU (rp4440). La advertencia que\
    \ agregu\xE9 a Flush_cache_page_if_present para detectar p\xE1ginas que no se\
    \ pod\xEDan vaciar se activaba con frecuencia en algunos sistemas. Helge y yo\
    \ miramos las p\xE1ginas que no se pod\xEDan vaciar y descubrimos que la PTE estaba\
    \ vac\xEDa o era una p\xE1gina de intercambio. Ignorar las p\xE1ginas que se intercambiaron\
    \ parec\xEDa estar bien, pero las p\xE1ginas con PTE borradas parec\xEDan problem\xE1\
    ticas. Mir\xE9 rutinas relacionadas con pte_clear y not\xE9 ptep_clear_flush.\
    \ La implementaci\xF3n predeterminada simplemente vac\xEDa la entrada TLB. Sin\
    \ embargo, era obvio que en Par\xEDs tambi\xE9n necesitamos vaciar la p\xE1gina\
    \ de cach\xE9. Si no limpiamos la p\xE1gina de cach\xE9, quedar\xE1n l\xEDneas\
    \ obsoletas en la cach\xE9 y provocar\xE1n da\xF1os aleatorios. Una vez que se\
    \ borra una PTE, no hay forma de encontrar la direcci\xF3n f\xEDsica asociada\
    \ con la PTE y borrar la p\xE1gina asociada m\xE1s adelante.  ---truncado---"
id: CVE-2024-40918
lastModified: '2024-07-12T16:34:58.687'
metrics: {}
published: '2024-07-12T13:15:14.863'
references:
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/5bf196f1936bf93df31112fbdfb78c03537c07b0
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/72d95924ee35c8cd16ef52f912483ee938a34d49
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/d66f2607d89f760cdffed88b22f309c895a2af20
sourceIdentifier: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
vulnStatus: Awaiting Analysis
