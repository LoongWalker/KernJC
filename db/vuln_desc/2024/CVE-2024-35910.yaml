cveTags: []
descriptions:
- lang: en
  value: 'In the Linux kernel, the following vulnerability has been resolved:


    tcp: properly terminate timers for kernel sockets


    We had various syzbot reports about tcp timers firing after

    the corresponding netns has been dismantled.


    Fortunately Josef Bacik could trigger the issue more often,

    and could test a patch I wrote two years ago.


    When TCP sockets are closed, we call inet_csk_clear_xmit_timers()

    to ''stop'' the timers.


    inet_csk_clear_xmit_timers() can be called from any context,

    including when socket lock is held.

    This is the reason it uses sk_stop_timer(), aka del_timer().

    This means that ongoing timers might finish much later.


    For user sockets, this is fine because each running timer

    holds a reference on the socket, and the user socket holds

    a reference on the netns.


    For kernel sockets, we risk that the netns is freed before

    timer can complete, because kernel sockets do not hold

    reference on the netns.


    This patch adds inet_csk_clear_xmit_timers_sync() function

    that using sk_stop_timer_sync() to make sure all timers

    are terminated before the kernel socket is released.

    Modules using kernel sockets close them in their netns exit()

    handler.


    Also add sock_not_owned_by_me() helper to get LOCKDEP

    support : inet_csk_clear_xmit_timers_sync() must not be called

    while socket lock is held.


    It is very possible we can revert in the future commit

    3a58f13a881e ("net: rds: acquire refcount on TCP sockets")

    which attempted to solve the issue in rds only.

    (net/smc/af_smc.c and net/mptcp/subflow.c have similar code)


    We probably can remove the check_net() tests from

    tcp_out_of_resources() and __tcp_close() in the future.'
- lang: es
  value: "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: tcp:\
    \ termina correctamente los temporizadores para los sockets del kernel. Recibimos\
    \ varios informes de syzbot sobre los temporizadores tcp que se activan despu\xE9\
    s de que se han desmantelado las redes correspondientes. Afortunadamente, Josef\
    \ Bacik pudo provocar el problema con m\xE1s frecuencia y pudo probar un parche\
    \ que escrib\xED hace dos a\xF1os. Cuando los sockets TCP est\xE1n cerrados, llamamos\
    \ a inet_csk_clear_xmit_timers() para \"detener\" los temporizadores. Se puede\
    \ llamar a inet_csk_clear_xmit_timers() desde cualquier contexto, incluso cuando\
    \ se mantiene el bloqueo del socket. Esta es la raz\xF3n por la que usa sk_stop_timer(),\
    \ tambi\xE9n conocido como del_timer(). Esto significa que los cron\xF3metros\
    \ en curso podr\xEDan finalizar mucho m\xE1s tarde. Para los sockets de usuario,\
    \ esto est\xE1 bien porque cada temporizador en ejecuci\xF3n tiene una referencia\
    \ en el socket, y el socket de usuario tiene una referencia en las redes. Para\
    \ los sockets del kernel, corremos el riesgo de que la red se libere antes de\
    \ que se complete el temporizador, porque los sockets del kernel no mantienen\
    \ referencias en las redes. Este parche agrega la funci\xF3n inet_csk_clear_xmit_timers_sync()\
    \ que usa sk_stop_timer_sync() para garantizar que todos los temporizadores finalicen\
    \ antes de que se libere el socket del kernel. Los m\xF3dulos que utilizan sockets\
    \ del kernel los cierran en su controlador netns exit(). Tambi\xE9n agregue el\
    \ asistente sock_not_owned_by_me() para obtener soporte LOCKDEP: no se debe llamar\
    \ a inet_csk_clear_xmit_timers_sync() mientras se mantiene el bloqueo del socket.\
    \ Es muy posible que podamos revertir en el futuro la confirmaci\xF3n 3a58f13a881e\
    \ (\"net: rds: adquirir refcount en sockets TCP\") que intent\xF3 resolver el\
    \ problema solo en rds. (net/smc/af_smc.c y net/mptcp/subflow.c tienen c\xF3digo\
    \ similar) Probablemente podamos eliminar las pruebas check_net() de tcp_out_of_resources()\
    \ y __tcp_close() en el futuro."
id: CVE-2024-35910
lastModified: '2024-06-27T12:15:26.153'
metrics: {}
published: '2024-05-19T09:15:11.617'
references:
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/151c9c724d05d5b0dd8acd3e11cb69ef1f2dbada
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/2e43d8eba6edd1cf05a3a20fdd77688fa7ec16a4
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/44e62f5d35678686734afd47c6a421ad30772e7f
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/899265c1389fe022802aae73dbf13ee08837a35a
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/91b243de910a9ac8476d40238ab3dbfeedd5b7de
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/93f0133b9d589cc6e865f254ad9be3e9d8133f50
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/c1ae4d1e76eacddaacb958b67cd942082f800c87
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/e3e27d2b446deb1f643758a0c4731f5c22492810
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://lists.debian.org/debian-lts-announce/2024/06/msg00020.html
sourceIdentifier: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
vulnStatus: Awaiting Analysis
