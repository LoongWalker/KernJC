configurations:
- nodes:
  - cpeMatch:
    - criteria: cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*
      matchCriteriaId: 5F2E2CF9-E512-4F81-AD6C-400701BDBF04
      versionEndExcluding: 6.1.97
      versionStartIncluding: '5.8'
      vulnerable: true
    - criteria: cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*
      matchCriteriaId: D72E033B-5323-4C4D-8818-36E1EBC3535F
      versionEndExcluding: 6.6.37
      versionStartIncluding: '6.2'
      vulnerable: true
    - criteria: cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*
      matchCriteriaId: E95105F2-32E3-4C5F-9D18-7AEFD0E6275C
      versionEndExcluding: 6.9.8
      versionStartIncluding: '6.7'
      vulnerable: true
    negate: false
    operator: OR
cveTags: []
descriptions:
- lang: en
  value: 'In the Linux kernel, the following vulnerability has been resolved:


    bpf: Fix overrunning reservations in ringbuf


    The BPF ring buffer internally is implemented as a power-of-2 sized circular

    buffer, with two logical and ever-increasing counters: consumer_pos is the

    consumer counter to show which logical position the consumer consumed the

    data, and producer_pos which is the producer counter denoting the amount of

    data reserved by all producers.


    Each time a record is reserved, the producer that "owns" the record will

    successfully advance producer counter. In user space each time a record is

    read, the consumer of the data advanced the consumer counter once it finished

    processing. Both counters are stored in separate pages so that from user

    space, the producer counter is read-only and the consumer counter is read-write.


    One aspect that simplifies and thus speeds up the implementation of both

    producers and consumers is how the data area is mapped twice contiguously

    back-to-back in the virtual memory, allowing to not take any special measures

    for samples that have to wrap around at the end of the circular buffer data

    area, because the next page after the last data page would be first data page

    again, and thus the sample will still appear completely contiguous in virtual

    memory.


    Each record has a struct bpf_ringbuf_hdr { u32 len; u32 pg_off; } header for

    book-keeping the length and offset, and is inaccessible to the BPF program.

    Helpers like bpf_ringbuf_reserve() return `(void *)hdr + BPF_RINGBUF_HDR_SZ`

    for the BPF program to use. Bing-Jhong and Muhammad reported that it is however

    possible to make a second allocated memory chunk overlapping with the first

    chunk and as a result, the BPF program is now able to edit first chunk''s

    header.


    For example, consider the creation of a BPF_MAP_TYPE_RINGBUF map with size

    of 0x4000. Next, the consumer_pos is modified to 0x3000 /before/ a call to

    bpf_ringbuf_reserve() is made. This will allocate a chunk A, which is in

    [0x0,0x3008], and the BPF program is able to edit [0x8,0x3008]. Now, lets

    allocate a chunk B with size 0x3000. This will succeed because consumer_pos

    was edited ahead of time to pass the `new_prod_pos - cons_pos > rb->mask`

    check. Chunk B will be in range [0x3008,0x6010], and the BPF program is able

    to edit [0x3010,0x6010]. Due to the ring buffer memory layout mentioned

    earlier, the ranges [0x0,0x4000] and [0x4000,0x8000] point to the same data

    pages. This means that chunk B at [0x4000,0x4008] is chunk A''s header.

    bpf_ringbuf_submit() / bpf_ringbuf_discard() use the header''s pg_off to then

    locate the bpf_ringbuf itself via bpf_ringbuf_restore_from_rec(). Once chunk

    B modified chunk A''s header, then bpf_ringbuf_commit() refers to the wrong

    page and could cause a crash.


    Fix it by calculating the oldest pending_pos and check whether the range

    from the oldest outstanding record to the newest would span beyond the ring

    buffer size. If that is the case, then reject the request. We''ve tested with

    the ring buffer benchmark in BPF selftests (./benchs/run_bench_ringbufs.sh)

    before/after the fix and while it seems a bit slower on some benchmarks, it

    is still not significantly enough to matter.'
- lang: es
  value: "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: bpf:\
    \ corrige el exceso de reservas en ringbuf. El b\xFAfer de anillo BPF se implementa\
    \ internamente como un b\xFAfer circular de tama\xF1o potencia de 2, con dos contadores\
    \ l\xF3gicos y en constante aumento: consumer_pos es el consumidor contador para\
    \ mostrar en qu\xE9 posici\xF3n l\xF3gica el consumidor consumi\xF3 los datos,\
    \ y productor_pos, que es el contador del productor que indica la cantidad de\
    \ datos reservados por todos los productores. Cada vez que se reserva un registro,\
    \ el productor \"due\xF1o\" del registro avanzar\xE1 exitosamente el contador\
    \ de productores. En el espacio de usuario, cada vez que se lee un registro, el\
    \ consumidor de los datos avanza el contador del consumidor una vez que finaliza\
    \ el procesamiento. Ambos contadores se almacenan en p\xE1ginas separadas de modo\
    \ que, desde el espacio del usuario, el contador del productor sea de solo lectura\
    \ y el contador del consumidor sea de lectura y escritura. Un aspecto que simplifica\
    \ y, por lo tanto, acelera la implementaci\xF3n tanto de productores como de consumidores\
    \ es c\xF3mo el \xE1rea de datos se mapea dos veces de forma contigua y consecutiva\
    \ en la memoria virtual, lo que permite no tomar medidas especiales para las muestras\
    \ que tienen que envolverse en el mismo lugar. al final del \xE1rea de datos del\
    \ b\xFAfer circular, porque la p\xE1gina siguiente despu\xE9s de la \xFAltima\
    \ p\xE1gina de datos volver\xEDa a ser la primera p\xE1gina de datos y, por lo\
    \ tanto, la muestra seguir\xE1 apareciendo completamente contigua en la memoria\
    \ virtual. Cada registro tiene una estructura bpf_ringbuf_hdr { u32 len; u32 p\xE1\
    gina_apagada; } encabezado para la contabilidad de la longitud y el desplazamiento,\
    \ y es inaccesible para el programa BPF. Ayudantes como bpf_ringbuf_reserve()\
    \ devuelven `(void *)hdr + BPF_RINGBUF_HDR_SZ` para que lo use el programa BPF.\
    \ Bing-Jhong y Muhammad informaron que, sin embargo, es posible hacer que un segundo\
    \ fragmento de memoria asignado se superponga con el primer fragmento y, como\
    \ resultado, el programa BPF ahora puede editar el encabezado del primer fragmento.\
    \ Por ejemplo, considere la creaci\xF3n de un mapa BPF_MAP_TYPE_RINGBUF con un\
    \ tama\xF1o de 0x4000. A continuaci\xF3n, consumer_pos se modifica a 0x3000 /antes/\
    \ se realiza una llamada a bpf_ringbuf_reserve(). Esto asignar\xE1 un fragmento\
    \ A, que est\xE1 en [0x0,0x3008], y el programa BPF podr\xE1 editar [0x8,0x3008].\
    \ Ahora, asignemos un fragmento B con tama\xF1o 0x3000. Esto tendr\xE1 \xE9xito\
    \ porque consumer_pos se edit\xF3 con anticipaci\xF3n para pasar la verificaci\xF3\
    n `new_prod_pos - cons_pos &gt; rb-&gt;mask`. El fragmento B estar\xE1 en el rango\
    \ [0x3008,0x6010] y el programa BPF podr\xE1 editar [0x3010,0x6010]. Debido al\
    \ dise\xF1o de la memoria del b\xFAfer en anillo mencionado anteriormente, los\
    \ rangos [0x0,0x4000] y [0x4000,0x8000] apuntan a las mismas p\xE1ginas de datos.\
    \ Esto significa que el fragmento B en [0x4000,0x4008] es el encabezado del fragmento\
    \ A. bpf_ringbuf_submit() / bpf_ringbuf_discard() usa el pg_off del encabezado\
    \ para luego ubicar el bpf_ringbuf a trav\xE9s de bpf_ringbuf_restore_from_rec().\
    \ Una vez que el fragmento B modific\xF3 el encabezado del fragmento A, bpf_ringbuf_commit()\
    \ hace referencia a la p\xE1gina incorrecta y podr\xEDa causar un bloqueo. Solucionelo\
    \ calculando el pendiente_pos m\xE1s antiguo y verifique si el rango desde el\
    \ registro pendiente m\xE1s antiguo hasta el m\xE1s nuevo abarcar\xEDa m\xE1s\
    \ all\xE1 del tama\xF1o del b\xFAfer circular. Si ese es el caso, rechace la solicitud.\
    \ Hemos probado con el punto de referencia del b\xFAfer de anillo en las autopruebas\
    \ de BPF (./benchs/run_bench_ringbufs.sh) antes/despu\xE9s de la correcci\xF3\
    n y, aunque parece un poco m\xE1s lento en algunos puntos de referencia, todav\xED\
    a no es lo suficientemente significativo como para importar."
id: CVE-2024-41009
lastModified: '2024-07-29T07:15:04.560'
metrics:
  cvssMetricV31:
  - cvssData:
      attackComplexity: LOW
      attackVector: LOCAL
      availabilityImpact: HIGH
      baseScore: 5.5
      baseSeverity: MEDIUM
      confidentialityImpact: NONE
      integrityImpact: NONE
      privilegesRequired: LOW
      scope: UNCHANGED
      userInteraction: NONE
      vectorString: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
      version: '3.1'
    exploitabilityScore: 1.8
    impactScore: 3.6
    source: nvd@nist.gov
    type: Primary
published: '2024-07-17T07:15:01.973'
references:
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/0f98f40eb1ed52af8b81f61901b6c0289ff59de4
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  tags:
  - Mailing List
  - Patch
  url: https://git.kernel.org/stable/c/47416c852f2a04d348ea66ee451cbdcf8119f225
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  tags:
  - Mailing List
  - Patch
  url: https://git.kernel.org/stable/c/511804ab701c0503b72eac08217eabfd366ba069
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/be35504b959f2749bab280f4671e8df96dcf836f
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  tags:
  - Mailing List
  - Patch
  url: https://git.kernel.org/stable/c/cfa1a2329a691ffd991fcf7248a57d752e712881
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  tags:
  - Mailing List
  - Patch
  url: https://git.kernel.org/stable/c/d1b9df0435bc61e0b44f578846516df8ef476686
sourceIdentifier: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
vulnStatus: Modified
weaknesses:
- description:
  - lang: en
    value: CWE-770
  source: nvd@nist.gov
  type: Primary
