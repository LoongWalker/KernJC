cveTags: []
descriptions:
- lang: en
  value: 'In the Linux kernel, the following vulnerability has been resolved:


    m68k: Fix spinlock race in kernel thread creation


    Context switching does take care to retain the correct lock owner across

    the switch from ''prev'' to ''next'' tasks.  This does rely on interrupts

    remaining disabled for the entire duration of the switch.


    This condition is guaranteed for normal process creation and context

    switching between already running processes, because both ''prev'' and

    ''next'' already have interrupts disabled in their saved copies of the

    status register.


    The situation is different for newly created kernel threads.  The status

    register is set to PS_S in copy_thread(), which does leave the IPL at 0.

    Upon restoring the ''next'' thread''s status register in switch_to() aka

    resume(), interrupts then become enabled prematurely.  resume() then

    returns via ret_from_kernel_thread() and schedule_tail() where run queue

    lock is released (see finish_task_switch() and finish_lock_switch()).


    A timer interrupt calling scheduler_tick() before the lock is released

    in finish_task_switch() will find the lock already taken, with the

    current task as lock owner.  This causes a spinlock recursion warning as

    reported by Guenter Roeck.


    As far as I can ascertain, this race has been opened in commit

    533e6903bea0 ("m68k: split ret_from_fork(), simplify kernel_thread()")

    but I haven''t done a detailed study of kernel history so it may well

    predate that commit.


    Interrupts cannot be disabled in the saved status register copy for

    kernel threads (init will complain about interrupts disabled when

    finally starting user space).  Disable interrupts temporarily when

    switching the tasks'' register sets in resume().


    Note that a simple oriw 0x700,%sr after restoring sr is not enough here

    - this leaves enough of a race for the ''spinlock recursion'' warning to

    still be observed.


    Tested on ARAnyM and qemu (Quadra 800 emulation).'
- lang: es
  value: "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: m68k:\
    \ corrige la ejecuci\xF3n de bloqueo de giro en la creaci\xF3n de subprocesos\
    \ del kernel. El cambio de contexto se encarga de retener el propietario del bloqueo\
    \ correcto durante el cambio de las tareas 'anteriores' a las 'siguientes'. Esto\
    \ depende de que las interrupciones permanezcan deshabilitadas durante toda la\
    \ duraci\xF3n del cambio. Esta condici\xF3n est\xE1 garantizada para la creaci\xF3\
    n normal de procesos y el cambio de contexto entre procesos que ya se est\xE1\
    n ejecutando, porque tanto 'anterior' como 'siguiente' ya tienen las interrupciones\
    \ deshabilitadas en sus copias guardadas del registro de estado. La situaci\xF3\
    n es diferente para los subprocesos del kernel reci\xE9n creados. El registro\
    \ de estado se establece en PS_S en copy_thread(), lo que deja la IPL en 0. Al\
    \ restaurar el registro de estado del 'siguiente' subproceso en switch_to() tambi\xE9\
    n conocido como resume(), las interrupciones se habilitan prematuramente. resume()\
    \ luego regresa a trav\xE9s de ret_from_kernel_thread() y Schedule_tail() donde\
    \ se libera el bloqueo de la cola de ejecuci\xF3n (consulte Finish_task_switch()\
    \ y Finish_lock_switch()). Una interrupci\xF3n del temporizador que llama a Scheduler_tick()\
    \ antes de que se libere el bloqueo en Finish_task_switch() encontrar\xE1 el bloqueo\
    \ ya tomado, con la tarea actual como propietario del bloqueo. Esto provoca una\
    \ advertencia de recursividad de spinlock seg\xFAn lo informado por Guenter Roeck.\
    \ Hasta donde puedo determinar, esta ejecuci\xF3n se abri\xF3 en el commit 533e6903bea0\
    \ (\"m68k: split ret_from_fork(), simplifica kernel_thread()\") pero no he realizado\
    \ un estudio detallado de la historia del kernel, por lo que es posible que sea\
    \ anterior a esa confirmaci\xF3n. Las interrupciones no se pueden deshabilitar\
    \ en la copia del registro de estado guardado para los subprocesos del kernel\
    \ (init se quejar\xE1 de las interrupciones deshabilitadas cuando finalmente inicie\
    \ el espacio de usuario). Deshabilite las interrupciones temporalmente al cambiar\
    \ los conjuntos de registros de tareas en resume(). Tenga en cuenta que un simple\
    \ oriw 0x700,%sr despu\xE9s de restaurar sr no es suficiente aqu\xED; esto deja\
    \ suficiente ejecuci\xF3n para que a\xFAn se observe la advertencia de 'recursi\xF3\
    n de spinlock'. Probado en ARAnyM y qemu (emulaci\xF3n Quadra 800)."
id: CVE-2024-38613
lastModified: '2024-06-20T12:43:25.663'
metrics: {}
published: '2024-06-19T14:15:21.147'
references:
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/0d9ae1253535f6e85a016e09c25ecbe6f7f59ef0
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/2a8d1d95302c7d52c6ac8fa5cb4a6948ae0d3a14
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/4eeffecc8e3cce25bb559502c2fd94a948bcde82
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/5213cc01d0464c011fdc09f318705603ed3a746b
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/77b2b67a0f8bce260c53907e5749d61466d90c87
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/95f00caf767b5968c2c51083957b38be4748a78a
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/da89ce46f02470ef08f0f580755d14d547da59ed
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/f1d4274a84c069be0f6098ab10c3443fc1f7134c
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/f3baf0f4f92af32943ebf27b960e0552c6c082fd
sourceIdentifier: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
vulnStatus: Awaiting Analysis
