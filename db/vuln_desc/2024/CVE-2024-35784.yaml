cveTags: []
descriptions:
- lang: en
  value: 'In the Linux kernel, the following vulnerability has been resolved:


    btrfs: fix deadlock with fiemap and extent locking


    While working on the patchset to remove extent locking I got a lockdep

    splat with fiemap and pagefaulting with my new extent lock replacement

    lock.


    This deadlock exists with our normal code, we just don''t have lockdep

    annotations with the extent locking so we''ve never noticed it.


    Since we''re copying the fiemap extent to user space on every iteration

    we have the chance of pagefaulting.  Because we hold the extent lock for

    the entire range we could mkwrite into a range in the file that we have

    mmap''ed.  This would deadlock with the following stack trace


    [<0>] lock_extent+0x28d/0x2f0

    [<0>] btrfs_page_mkwrite+0x273/0x8a0

    [<0>] do_page_mkwrite+0x50/0xb0

    [<0>] do_fault+0xc1/0x7b0

    [<0>] __handle_mm_fault+0x2fa/0x460

    [<0>] handle_mm_fault+0xa4/0x330

    [<0>] do_user_addr_fault+0x1f4/0x800

    [<0>] exc_page_fault+0x7c/0x1e0

    [<0>] asm_exc_page_fault+0x26/0x30

    [<0>] rep_movs_alternative+0x33/0x70

    [<0>] _copy_to_user+0x49/0x70

    [<0>] fiemap_fill_next_extent+0xc8/0x120

    [<0>] emit_fiemap_extent+0x4d/0xa0

    [<0>] extent_fiemap+0x7f8/0xad0

    [<0>] btrfs_fiemap+0x49/0x80

    [<0>] __x64_sys_ioctl+0x3e1/0xb50

    [<0>] do_syscall_64+0x94/0x1a0

    [<0>] entry_SYSCALL_64_after_hwframe+0x6e/0x76


    I wrote an fstest to reproduce this deadlock without my replacement lock

    and verified that the deadlock exists with our existing locking.


    To fix this simply don''t take the extent lock for the entire duration of

    the fiemap.  This is safe in general because we keep track of where we

    are when we''re searching the tree, so if an ordered extent updates in

    the middle of our fiemap call we''ll still emit the correct extents

    because we know what offset we were on before.


    The only place we maintain the lock is searching delalloc.  Since the

    delalloc stuff can change during writeback we want to lock the extent

    range so we have a consistent view of delalloc at the time we''re

    checking to see if we need to set the delalloc flag.


    With this patch applied we no longer deadlock with my testcase.'
- lang: es
  value: "En el kernel de Linux, se resolvi\xF3 la siguiente vulnerabilidad: btrfs:\
    \ soluciona el punto muerto con fiemap y bloqueo de extensi\xF3n Mientras trabajaba\
    \ en el conjunto de parches para eliminar el bloqueo de extensi\xF3n, obtuve un\
    \ lockdep splat con fiemap y pagefaulting con mi nuevo bloqueo de reemplazo de\
    \ bloqueo de extensi\xF3n. Este punto muerto existe con nuestro c\xF3digo normal,\
    \ simplemente no tenemos anotaciones de bloqueo con el bloqueo de extensi\xF3\
    n, por lo que nunca lo hemos notado. Dado que copiamos la extensi\xF3n del mapa\
    \ de archivos al espacio del usuario en cada iteraci\xF3n, tenemos la posibilidad\
    \ de que se produzcan errores de p\xE1gina. Debido a que mantenemos el bloqueo\
    \ de extensi\xF3n para todo el rango, podemos escribir en un rango en el archivo\
    \ que hemos asignado. Esto se bloquear\xEDa con el siguiente seguimiento de pila\
    \ [&lt;0&gt;] lock_extent+0x28d/0x2f0 [&lt;0&gt;] btrfs_page_mkwrite+0x273/0x8a0\
    \ [&lt;0&gt;] do_page_mkwrite+0x50/0xb0 [&lt;0&gt;] do_fault+0xc1/0x7b0 [&lt;\
    \ 0&gt;] __handle_mm_fault+0x2fa/0x460 [&lt;0&gt;] handle_mm_fault+0xa4/0x330\
    \ [&lt;0&gt;] do_user_addr_fault+0x1f4/0x800 [&lt;0&gt;] exc_page_fault+0x7c/0x1e0\
    \ [&lt;0&gt;] asm_exc_page_fault+0x26/0x30 [&lt; 0&gt;] rep_movs_alternative+0x33/0x70\
    \ [&lt;0&gt;] _copy_to_user+0x49/0x70 [&lt;0&gt;] fiemap_fill_next_extent+0xc8/0x120\
    \ [&lt;0&gt;] emit_fiemap_extent+0x4d/0xa0 [&lt;0&gt;] extend_fiemap+0x7f8/0xad0\
    \ [&lt; 0&gt;] btrfs_fiemap+0x49/0x80 [&lt;0&gt;] __x64_sys_ioctl+0x3e1/0xb50\
    \ [&lt;0&gt;] do_syscall_64+0x94/0x1a0 [&lt;0&gt;] Entry_SYSCALL_64_after_hwframe+0x6e/0x76\
    \ Escrib\xED un fstest para reproducir este interbloqueo sin mi bloqueo de reemplazo\
    \ y verifiqu\xE9 que existe un punto muerto con nuestro bloqueo existente. Para\
    \ solucionar este problema, simplemente no utilice el bloqueo de extensi\xF3n\
    \ durante toda la duraci\xF3n del mapa de archivos. En general, esto es seguro\
    \ porque realizamos un seguimiento de d\xF3nde estamos cuando buscamos en el \xE1\
    rbol, por lo que si una extensi\xF3n ordenada se actualiza en medio de nuestra\
    \ llamada a fiemap, seguiremos emitiendo las extensiones correctas porque sabemos\
    \ en qu\xE9 desplazamiento est\xE1bamos. antes. El \xFAnico lugar donde mantenemos\
    \ el bloqueo es buscando en delalloc. Dado que las cosas de delalloc pueden cambiar\
    \ durante la reescritura, queremos bloquear el rango de extensi\xF3n para tener\
    \ una vista consistente de delalloc en el momento en que verificamos si necesitamos\
    \ configurar el indicador delalloc. Con este parche aplicado ya no nos estancamos\
    \ con mi caso de prueba."
id: CVE-2024-35784
lastModified: '2024-05-17T18:35:35.070'
metrics: {}
published: '2024-05-17T13:15:58.270'
references:
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/89bca7fe6382d61e88c67a0b0e7bce315986fb8b
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/b0ad381fa7690244802aed119b478b4bdafc31dd
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/ded566b4637f1b6b4c9ba74e7d0b8493e93f19cf
sourceIdentifier: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
vulnStatus: Awaiting Analysis
