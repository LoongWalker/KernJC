descriptions:
- lang: en
  value: 'In the Linux kernel, the following vulnerability has been resolved:


    PCI/PM: Drain runtime-idle callbacks before driver removal


    A race condition between the .runtime_idle() callback and the .remove()

    callback in the rtsx_pcr PCI driver leads to a kernel crash due to an

    unhandled page fault [1].


    The problem is that rtsx_pci_runtime_idle() is not expected to be running

    after pm_runtime_get_sync() has been called, but the latter doesn''t really

    guarantee that.  It only guarantees that the suspend and resume callbacks

    will not be running when it returns.


    However, if a .runtime_idle() callback is already running when

    pm_runtime_get_sync() is called, the latter will notice that the runtime PM

    status of the device is RPM_ACTIVE and it will return right away without

    waiting for the former to complete.  In fact, it cannot wait for

    .runtime_idle() to complete because it may be called from that callback (it

    arguably does not make much sense to do that, but it is not strictly

    prohibited).


    Thus in general, whoever is providing a .runtime_idle() callback needs

    to protect it from running in parallel with whatever code runs after

    pm_runtime_get_sync().  [Note that .runtime_idle() will not start after

    pm_runtime_get_sync() has returned, but it may continue running then if it

    has started earlier.]


    One way to address that race condition is to call pm_runtime_barrier()

    after pm_runtime_get_sync() (not before it, because a nonzero value of the

    runtime PM usage counter is necessary to prevent runtime PM callbacks from

    being invoked) to wait for the .runtime_idle() callback to complete should

    it be running at that point.  A suitable place for doing that is in

    pci_device_remove() which calls pm_runtime_get_sync() before removing the

    driver, so it may as well call pm_runtime_barrier() subsequently, which

    will prevent the race in question from occurring, not just in the rtsx_pcr

    driver, but in any PCI drivers providing .runtime_idle() callbacks.'
- lang: es
  value: "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: PCI/PM:\
    \ drena las devoluciones de llamada inactivas en tiempo de ejecuci\xF3n antes\
    \ de eliminar el controlador. Una condici\xF3n de ejecuci\xF3n entre la devoluci\xF3\
    n de llamada .runtime_idle() y la devoluci\xF3n de llamada .remove() en el controlador\
    \ PCI rtsx_pcr conduce a un crash de kernel debido a un error de p\xE1gina no\
    \ controlado [1]. El problema es que no se espera que rtsx_pci_runtime_idle()\
    \ se ejecute despu\xE9s de llamar a pm_runtime_get_sync(), pero esto \xFAltimo\
    \ realmente no garantiza eso. Solo garantiza que las devoluciones de llamada de\
    \ suspensi\xF3n y reanudaci\xF3n no se ejecutar\xE1n cuando regrese. Sin embargo,\
    \ si ya se est\xE1 ejecutando una devoluci\xF3n de llamada .runtime_idle() cuando\
    \ se llama a pm_runtime_get_sync(), este \xFAltimo notar\xE1 que el estado de\
    \ PM en tiempo de ejecuci\xF3n del dispositivo es RPM_ACTIVE y regresar\xE1 de\
    \ inmediato sin esperar a que se complete el primero. De hecho, no puede esperar\
    \ a que se complete .runtime_idle() porque puede ser llamado desde esa devoluci\xF3\
    n de llamada (podr\xEDa decirse que no tiene mucho sentido hacerlo, pero no est\xE1\
    \ estrictamente prohibido). Por lo tanto, en general, quien proporciona una devoluci\xF3\
    n de llamada .runtime_idle() debe protegerla para que no se ejecute en paralelo\
    \ con cualquier c\xF3digo que se ejecute despu\xE9s de pm_runtime_get_sync().\
    \ [Tenga en cuenta que .runtime_idle() no se iniciar\xE1 despu\xE9s de que pm_runtime_get_sync()\
    \ haya regresado, pero puede continuar ejecut\xE1ndose si comenz\xF3 antes.] Una\
    \ forma de abordar esa condici\xF3n de ejecuci\xF3n es llamar a pm_runtime_barrier()\
    \ despu\xE9s de pm_runtime_get_sync() (no antes porque es necesario un valor distinto\
    \ de cero del contador de uso de PM en tiempo de ejecuci\xF3n para evitar que\
    \ se invoquen devoluciones de llamada de PM en tiempo de ejecuci\xF3n) para esperar\
    \ a que se complete la devoluci\xF3n de llamada .runtime_idle() en caso de que\
    \ se est\xE9 ejecutando en ese punto. Un lugar adecuado para hacerlo es pci_device_remove()\
    \ que llama a pm_runtime_get_sync() antes de eliminar el controlador, por lo que\
    \ tambi\xE9n puede llamar a pm_runtime_barrier() posteriormente, lo que evitar\xE1\
    \ que se produzca la ejecuci\xF3n en cuesti\xF3n, no s\xF3lo en el controlador\
    \ rtsx_pcr, sino en cualquier controlador PCI que proporcione devoluciones de\
    \ llamada .runtime_idle()."
id: CVE-2024-35809
lastModified: '2024-06-25T23:15:30.337'
metrics: {}
published: '2024-05-17T14:15:14.730'
references:
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/47d8aafcfe313511a98f165a54d0adceb34e54b1
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/6347348c6aba52dda0b33296684cbb627bdc6970
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/7cc94dd36e48879e76ae7a8daea4ff322b7d9674
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/900b81caf00c89417172afe0e7e49ac4eb110f4b
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/9a87375bb586515c0af63d5dcdcd58ec4acf20a6
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/9d5286d4e7f68beab450deddbb6a32edd5ecf4bf
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/bbe068b24409ef740657215605284fc7cdddd491
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/d534198311c345e4b062c4b88bb609efb8bd91d5
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/d86ad8c3e152349454b82f37007ff6ba45f26989
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html
sourceIdentifier: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
vulnStatus: Awaiting Analysis
