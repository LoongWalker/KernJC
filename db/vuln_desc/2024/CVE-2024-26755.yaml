cveTags: []
descriptions:
- lang: en
  value: "In the Linux kernel, the following vulnerability has been resolved:\n\n\
    md: Don't suspend the array for interrupted reshape\n\nmd_start_sync() will suspend\
    \ the array if there are spares that can be\nadded or removed from conf, however,\
    \ if reshape is still in progress,\nthis won't happen at all or data will be corrupted(remove_and_add_spares\n\
    won't be called from md_choose_sync_action for reshape), hence there is\nno need\
    \ to suspend the array if reshape is not done yet.\n\nMeanwhile, there is a potential\
    \ deadlock for raid456:\n\n1) reshape is interrupted;\n\n2) set one of the disk\
    \ WantReplacement, and add a new disk to the array,\n   however, recovery won't\
    \ start until the reshape is finished;\n\n3) then issue an IO across reshpae position,\
    \ this IO will wait for\n   reshape to make progress;\n\n4) continue to reshape,\
    \ then md_start_sync() found there is a spare disk\n   that can be added to conf,\
    \ mddev_suspend() is called;\n\nStep 4 and step 3 is waiting for each other, deadlock\
    \ triggered. Noted\nthis problem is found by code review, and it's not reporduced\
    \ yet.\n\nFix this porblem by don't suspend the array for interrupted reshape,\n\
    this is safe because conf won't be changed until reshape is done."
- lang: es
  value: "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: md: No\
    \ suspender la matriz por remodelaci\xF3n interrumpida md_start_sync() suspender\xE1\
    \ la matriz si hay repuestos que se pueden agregar o eliminar de conf, sin embargo,\
    \ si la remodelaci\xF3n a\xFAn est\xE1 en marcha progreso, esto no suceder\xE1\
    \ en absoluto o los datos se da\xF1ar\xE1n (no se llamar\xE1 a remove_and_add_spares\
    \ desde md_choose_sync_action para remodelar), por lo tanto, no hay necesidad\
    \ de suspender la matriz si la remodelaci\xF3n a\xFAn no se ha realizado. Mientras\
    \ tanto, existe un posible punto muerto para raid456: 1) se interrumpe la remodelaci\xF3\
    n; 2) configure uno de los discos WantReplacement y agregue un nuevo disco a la\
    \ matriz; sin embargo, la recuperaci\xF3n no comenzar\xE1 hasta que finalice la\
    \ remodelaci\xF3n; 3) luego emita una IO a trav\xE9s de la posici\xF3n de reshpae,\
    \ esta IO esperar\xE1 a que la remodelaci\xF3n avance; 4) contin\xFAe remodelando,\
    \ luego md_start_sync() encontr\xF3 que hay un disco de repuesto que se puede\
    \ agregar a conf, se llama a mddev_suspend(); Los pasos 4 y 3 se esperan el uno\
    \ al otro y se activa el punto muerto. Observ\xE9 que este problema se encuentra\
    \ mediante la revisi\xF3n del c\xF3digo y a\xFAn no se ha informado. Solucione\
    \ este problema al no suspender la matriz durante una remodelaci\xF3n interrumpida,\
    \ esto es seguro porque la configuraci\xF3n no se cambiar\xE1 hasta que finalice\
    \ la remodelaci\xF3n."
id: CVE-2024-26755
lastModified: '2024-04-03T17:24:18.150'
metrics: {}
published: '2024-04-03T17:15:52.103'
references:
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/60d6130d0ac1d883ed93c2a1e10aadb60967fd48
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/9e46c70e829bddc24e04f963471e9983a11598b7
sourceIdentifier: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
vulnStatus: Awaiting Analysis
