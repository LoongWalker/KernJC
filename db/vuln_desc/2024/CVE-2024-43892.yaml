configurations:
- nodes:
  - cpeMatch:
    - criteria: cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*
      matchCriteriaId: ACA5323A-A089-48EF-85AA-99E8DF835386
      versionEndExcluding: 6.6.46
      versionStartIncluding: '4.7'
      vulnerable: true
    - criteria: cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*
      matchCriteriaId: D074AE50-4A5E-499C-A2FD-75FD60DEA560
      versionEndExcluding: 6.10.5
      versionStartIncluding: '6.7'
      vulnerable: true
    - criteria: cpe:2.3:o:linux:linux_kernel:6.11:rc1:*:*:*:*:*:*
      matchCriteriaId: 8B3CE743-2126-47A3-8B7C-822B502CF119
      vulnerable: true
    - criteria: cpe:2.3:o:linux:linux_kernel:6.11:rc2:*:*:*:*:*:*
      matchCriteriaId: 4DEB27E7-30AA-45CC-8934-B89263EF3551
      vulnerable: true
    negate: false
    operator: OR
cveTags: []
descriptions:
- lang: en
  value: 'In the Linux kernel, the following vulnerability has been resolved:


    memcg: protect concurrent access to mem_cgroup_idr


    Commit 73f576c04b94 ("mm: memcontrol: fix cgroup creation failure after

    many small jobs") decoupled the memcg IDs from the CSS ID space to fix the

    cgroup creation failures.  It introduced IDR to maintain the memcg ID

    space.  The IDR depends on external synchronization mechanisms for

    modifications.  For the mem_cgroup_idr, the idr_alloc() and idr_replace()

    happen within css callback and thus are protected through cgroup_mutex

    from concurrent modifications.  However idr_remove() for mem_cgroup_idr

    was not protected against concurrency and can be run concurrently for

    different memcgs when they hit their refcnt to zero.  Fix that.


    We have been seeing list_lru based kernel crashes at a low frequency in

    our fleet for a long time.  These crashes were in different part of

    list_lru code including list_lru_add(), list_lru_del() and reparenting

    code.  Upon further inspection, it looked like for a given object (dentry

    and inode), the super_block''s list_lru didn''t have list_lru_one for the

    memcg of that object.  The initial suspicions were either the object is

    not allocated through kmem_cache_alloc_lru() or somehow

    memcg_list_lru_alloc() failed to allocate list_lru_one() for a memcg but

    returned success.  No evidence were found for these cases.


    Looking more deeply, we started seeing situations where valid memcg''s id

    is not present in mem_cgroup_idr and in some cases multiple valid memcgs

    have same id and mem_cgroup_idr is pointing to one of them.  So, the most

    reasonable explanation is that these situations can happen due to race

    between multiple idr_remove() calls or race between

    idr_alloc()/idr_replace() and idr_remove().  These races are causing

    multiple memcgs to acquire the same ID and then offlining of one of them

    would cleanup list_lrus on the system for all of them.  Later access from

    other memcgs to the list_lru cause crashes due to missing list_lru_one.'
- lang: es
  value: "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: memcg:\
    \ protege el acceso simult\xE1neo a mem_cgroup_idr. el commit 73f576c04b94 (\"\
    mm: memcontrol: repara el error de creaci\xF3n de cgroup despu\xE9s de muchos\
    \ trabajos peque\xF1os\") desacopla los ID de memcg del espacio de ID de CSS para\
    \ reparar el cgroup. fracasos de la creaci\xF3n. Introdujo IDR para mantener el\
    \ espacio de identificaci\xF3n de memcg. El IDR depende de mecanismos externos\
    \ de sincronizaci\xF3n para las modificaciones. Para mem_cgroup_idr, idr_alloc()\
    \ e idr_replace() ocurren dentro de la devoluci\xF3n de llamada CSS y, por lo\
    \ tanto, est\xE1n protegidos a trav\xE9s de cgroup_mutex contra modificaciones\
    \ simult\xE1neas. Sin embargo, idr_remove() para mem_cgroup_idr no estaba protegido\
    \ contra la concurrencia y se puede ejecutar simult\xE1neamente para diferentes\
    \ memcgs cuando alcanzan su referencia a cero. Arregla eso. Hemos estado viendo\
    \ fallas del kernel basadas en list_lru con baja frecuencia en nuestra flota durante\
    \ mucho tiempo. Estos fallos se produjeron en diferentes partes del c\xF3digo\
    \ list_lru, incluidos list_lru_add(), list_lru_del() y el c\xF3digo de reparaci\xF3\
    n. Tras una inspecci\xF3n m\xE1s detallada, parec\xEDa que para un objeto determinado\
    \ (dentry e inodo), el list_lru del super_block no ten\xEDa list_lru_one para\
    \ el memcg de ese objeto. Las sospechas iniciales fueron que el objeto no estaba\
    \ asignado a trav\xE9s de kmem_cache_alloc_lru() o de alguna manera memcg_list_lru_alloc()\
    \ no pudo asignar list_lru_one() para un memcg pero devolvi\xF3 el \xE9xito. No\
    \ se encontraron pruebas de estos casos. Mirando m\xE1s profundamente, comenzamos\
    \ a ver situaciones en las que la identificaci\xF3n de memcg v\xE1lida no est\xE1\
    \ presente en mem_cgroup_idr y, en algunos casos, varios memcg v\xE1lidos tienen\
    \ la misma identificaci\xF3n y mem_cgroup_idr apunta a uno de ellos. Entonces,\
    \ la explicaci\xF3n m\xE1s razonable es que estas situaciones pueden ocurrir debido\
    \ a la ejecuci\xF3n entre m\xFAltiples llamadas idr_remove() o la ejecuci\xF3\
    n entre idr_alloc()/idr_replace() e idr_remove(). Estas ejecuciones est\xE1n provocando\
    \ que varios memcgs adquieran el mismo ID y luego desconectar uno de ellos limpiar\xED\
    a list_lrus en el sistema para todos ellos. El acceso posterior desde otros memcgs\
    \ a list_lru provoca bloqueos debido a que falta list_lru_one."
id: CVE-2024-43892
lastModified: '2024-09-05T18:41:38.723'
metrics:
  cvssMetricV31:
  - cvssData:
      attackComplexity: HIGH
      attackVector: LOCAL
      availabilityImpact: HIGH
      baseScore: 4.7
      baseSeverity: MEDIUM
      confidentialityImpact: NONE
      integrityImpact: NONE
      privilegesRequired: LOW
      scope: UNCHANGED
      userInteraction: NONE
      vectorString: CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H
      version: '3.1'
    exploitabilityScore: 1.0
    impactScore: 3.6
    source: nvd@nist.gov
    type: Primary
published: '2024-08-26T11:15:04.157'
references:
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  tags:
  - Patch
  url: https://git.kernel.org/stable/c/37a060b64ae83b76600d187d76591ce488ab836b
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  tags:
  - Patch
  url: https://git.kernel.org/stable/c/51c0b1bb7541f8893ec1accba59eb04361a70946
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  tags:
  - Patch
  url: https://git.kernel.org/stable/c/9972605a238339b85bd16b084eed5f18414d22db
sourceIdentifier: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
vulnStatus: Analyzed
weaknesses:
- description:
  - lang: en
    value: NVD-CWE-noinfo
  source: nvd@nist.gov
  type: Primary
