cveTags: []
descriptions:
- lang: en
  value: 'In the Linux kernel, the following vulnerability has been resolved:


    xhci: Handle TD clearing for multiple streams case


    When multiple streams are in use, multiple TDs might be in flight when

    an endpoint is stopped. We need to issue a Set TR Dequeue Pointer for

    each, to ensure everything is reset properly and the caches cleared.

    Change the logic so that any N>1 TDs found active for different streams

    are deferred until after the first one is processed, calling

    xhci_invalidate_cancelled_tds() again from xhci_handle_cmd_set_deq() to

    queue another command until we are done with all of them. Also change

    the error/"should never happen" paths to ensure we at least clear any

    affected TDs, even if we can''t issue a command to clear the hardware

    cache, and complain loudly with an xhci_warn() if this ever happens.


    This problem case dates back to commit e9df17eb1408 ("USB: xhci: Correct

    assumptions about number of rings per endpoint.") early on in the XHCI

    driver''s life, when stream support was first added.

    It was then identified but not fixed nor made into a warning in commit

    674f8438c121 ("xhci: split handling halted endpoints into two steps"),

    which added a FIXME comment for the problem case (without materially

    changing the behavior as far as I can tell, though the new logic made

    the problem more obvious).


    Then later, in commit 94f339147fc3 ("xhci: Fix failure to give back some

    cached cancelled URBs."), it was acknowledged again.


    [Mathias: commit 94f339147fc3 ("xhci: Fix failure to give back some cached

    cancelled URBs.") was a targeted regression fix to the previously mentioned

    patch. Users reported issues with usb stuck after unmounting/disconnecting

    UAS devices. This rolled back the TD clearing of multiple streams to its

    original state.]


    Apparently the commit author was aware of the problem (yet still chose

    to submit it): It was still mentioned as a FIXME, an xhci_dbg() was

    added to log the problem condition, and the remaining issue was mentioned

    in the commit description. The choice of making the log type xhci_dbg()

    for what is, at this point, a completely unhandled and known broken

    condition is puzzling and unfortunate, as it guarantees that no actual

    users would see the log in production, thereby making it nigh

    undebuggable (indeed, even if you turn on DEBUG, the message doesn''t

    really hint at there being a problem at all).


    It took me *months* of random xHC crashes to finally find a reliable

    repro and be able to do a deep dive debug session, which could all have

    been avoided had this unhandled, broken condition been actually reported

    with a warning, as it should have been as a bug intentionally left in

    unfixed (never mind that it shouldn''t have been left in at all).


    > Another fix to solve clearing the caches of all stream rings with

    > cancelled TDs is needed, but not as urgent.


    3 years after that statement and 14 years after the original bug was

    introduced, I think it''s finally time to fix it. And maybe next time

    let''s not leave bugs unfixed (that are actually worse than the original

    bug), and let''s actually get people to review kernel commits please.


    Fixes xHC crashes and IOMMU faults with UAS devices when handling

    errors/faults. Easiest repro is to use `hdparm` to mark an early sector

    (e.g. 1024) on a disk as bad, then `cat /dev/sdX > /dev/null` in a loop.

    At least in the case of JMicron controllers, the read errors end up

    having to cancel two TDs (for two queued requests to different streams)

    and the one that didn''t get cleared properly ends up faulting the xHC

    entirely when it tries to access DMA pages that have since been unmapped,

    referred to by the stale TDs. This normally happens quickly (after two

    or three loops). After this fix, I left the `cat` in a loop running

    overnight and experienced no xHC failures, with all read errors

    recovered properly. Repro''d and tested on an Apple M1 Mac Mini

    (dwc3 host).


    On systems without an IOMMU, this bug would instead silently corrupt

    freed memory, making this a

    ---truncated---'
- lang: es
  value: "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: xhci:\
    \ Manejar el borrado de TD para el caso de m\xFAltiples flujos Cuando se utilizan\
    \ m\xFAltiples flujos, es posible que haya m\xFAltiples TD en vuelo cuando se\
    \ detiene un endpoint. Necesitamos emitir un puntero de salida de cola TR para\
    \ cada uno, para garantizar que todo se restablezca correctamente y se borren\
    \ los cach\xE9s. Cambie la l\xF3gica para que cualquier N&gt;1 TD que se encuentre\
    \ activo para diferentes flujos se difiera hasta despu\xE9s de que se procese\
    \ el primero, llamando a xhci_invalidate_cancelled_tds() nuevamente desde xhci_handle_cmd_set_deq()\
    \ para poner en cola otro comando hasta que hayamos terminado con todos ellos.\
    \ Tambi\xE9n cambie las rutas de error/\"nunca deber\xEDa suceder\" para asegurarnos\
    \ de que al menos borramos los TD afectados, incluso si no podemos emitir un comando\
    \ para borrar el cach\xE9 del hardware, y quejarnos en voz alta con un xhci_warn()\
    \ si esto alguna vez sucede. Este caso de problema se remonta al commit e9df17eb1408\
    \ (\"USB: xhci: Suposiciones correctas sobre el n\xFAmero de anillos por endpoint.\"\
    ) al principio de la vida del controlador XHCI, cuando se agreg\xF3 por primera\
    \ vez el soporte de transmisi\xF3n. Luego se identific\xF3, pero no se solucion\xF3\
    \ ni se convirti\xF3 en una advertencia en el commit 674f8438c121 (\"xhci: dividir\
    \ el manejo de endpoints detenidos en dos pasos\"), que agreg\xF3 un comentario\
    \ FIXME para el caso del problema (sin cambiar materialmente el comportamiento,\
    \ hasta donde yo s\xE9). , aunque la nueva l\xF3gica hizo que el problema fuera\
    \ m\xE1s obvio). Luego, m\xE1s tarde, en el commit 94f339147fc3 (\"xhci: Se corrigi\xF3\
    \ el error al devolver algunas URB canceladas en cach\xE9\"), se reconoci\xF3\
    \ nuevamente. [Mathias: commit 94f339147fc3 (\"xhci: Se corrigi\xF3 el error al\
    \ devolver algunas URB canceladas en cach\xE9\") fue una soluci\xF3n de regresi\xF3\
    n espec\xEDfica para el parche mencionado anteriormente. Los usuarios informaron\
    \ problemas con el USB atascado despu\xE9s de desmontar/desconectar dispositivos\
    \ UAS. Esto revirti\xF3 la limpieza de TD de m\xFAltiples transmisiones a su estado\
    \ original.] Aparentemente, el autor de el commit estaba al tanto del problema\
    \ (pero a\xFAn as\xED decidi\xF3 enviarlo): todav\xEDa se mencionaba como FIXME,\
    \ se agreg\xF3 un xhci_dbg() para registrar el condici\xF3n del problema y el\
    \ problema restante se mencion\xF3 en la descripci\xF3n de El commit. La elecci\xF3\
    n de crear el tipo de registro xhci_dbg() para lo que, en este momento, es una\
    \ condici\xF3n rota completamente no controlada y conocida es desconcertante y\
    \ desafortunada, ya que garantiza que ning\xFAn usuario real ver\xE1 el registro\
    \ en producci\xF3n, lo que lo hace casi no depurable ( de hecho, incluso si activa\
    \ DEBUG, el mensaje realmente no indica que haya ning\xFAn problema). Me tom\xF3\
    \ *meses* de fallas aleatorias de xHC para finalmente encontrar una reproducci\xF3\
    n confiable y poder realizar una sesi\xF3n de depuraci\xF3n profunda, que podr\xED\
    a haberse evitado si esta condici\xF3n rota y no controlada se hubiera informado\
    \ con una advertencia, como deber\xEDa haber sido. ha sido un error que se dej\xF3\
    \ intencionalmente sin corregir (sin importar que no deber\xEDa haberse dejado\
    \ en absoluto). &gt; Se necesita otra soluci\xF3n para solucionar el borrado de\
    \ los cach\xE9s de todos los anillos de transmisi\xF3n con &gt; TD cancelados,\
    \ pero no es tan urgente. 3 a\xF1os despu\xE9s de esa declaraci\xF3n y 14 a\xF1\
    os despu\xE9s de que se introdujo el error original, creo que finalmente es hora\
    \ de solucionarlo. Y tal vez la pr\xF3xima vez no dejemos errores sin corregir\
    \ (que en realidad son peores que el error original), y hagamos que la gente revise\
    \ las confirmaciones del kernel, por favor. Soluciona fallas de xHC y fallas de\
    \ IOMMU con dispositivos UAS al manejar errores/fallas. La reproducci\xF3n m\xE1\
    s sencilla es usar `hdparm` para marcar un sector inicial (por ejemplo, 1024)\
    \ en un disco como defectuoso, luego `cat /dev/sdX &gt; /dev/null` en un bucle.\
    \ ---truncado---"
id: CVE-2024-40927
lastModified: '2024-07-12T16:34:58.687'
metrics: {}
published: '2024-07-12T13:15:15.477'
references:
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/26460c1afa311524f588e288a4941432f0de6228
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/5ceac4402f5d975e5a01c806438eb4e554771577
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/61593dc413c3655e4328a351555235bc3089486a
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/633f72cb6124ecda97b641fbc119340bd88d51a9
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/949be4ec5835e0ccb3e2a8ab0e46179cb5512518
sourceIdentifier: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
vulnStatus: Awaiting Analysis
