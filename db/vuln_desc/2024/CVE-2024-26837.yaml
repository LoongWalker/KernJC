descriptions:
- lang: en
  value: "In the Linux kernel, the following vulnerability has been resolved:\n\n\
    net: bridge: switchdev: Skip MDB replays of deferred events on offload\n\nBefore\
    \ this change, generation of the list of MDB events to replay\nwould race against\
    \ the creation of new group memberships, either from\nthe IGMP/MLD snooping logic\
    \ or from user configuration.\n\nWhile new memberships are immediately visible\
    \ to walkers of\nbr->mdb_list, the notification of their existence to switchdev\
    \ event\nsubscribers is deferred until a later point in time. So if a replay\n\
    list was generated during a time that overlapped with such a window,\nit would\
    \ also contain a replay of the not-yet-delivered event.\n\nThe driver would thus\
    \ receive two copies of what the bridge internally\nconsidered to be one single\
    \ event. On destruction of the bridge, only\na single membership deletion event\
    \ was therefore sent. As a\nconsequence of this, drivers which reference count\
    \ memberships (at\nleast DSA), would be left with orphan groups in their hardware\n\
    database when the bridge was destroyed.\n\nThis is only an issue when replaying\
    \ additions. While deletion events\nmay still be pending on the deferred queue,\
    \ they will already have\nbeen removed from br->mdb_list, so no duplicates can\
    \ be generated in\nthat scenario.\n\nTo a user this meant that old group memberships,\
    \ from a bridge in\nwhich a port was previously attached, could be reanimated\
    \ (in\nhardware) when the port joined a new bridge, without the new bridge's\n\
    knowledge.\n\nFor example, on an mv88e6xxx system, create a snooping bridge and\n\
    immediately add a port to it:\n\n    root@infix-06-0b-00:~$ ip link add dev br0\
    \ up type bridge mcast_snooping 1 && \\\n    > ip link set dev x3 up master br0\n\
    \nAnd then destroy the bridge:\n\n    root@infix-06-0b-00:~$ ip link del dev br0\n\
    \    root@infix-06-0b-00:~$ mvls atu\n    ADDRESS             FID  STATE     \
    \ Q  F  0  1  2  3  4  5  6  7  8  9  a\n    DEV:0 Marvell 88E6393X\n    33:33:00:00:00:6a\
    \     1  static     -  -  0  .  .  .  .  .  .  .  .  .  .\n    33:33:ff:87:e4:3f\
    \     1  static     -  -  0  .  .  .  .  .  .  .  .  .  .\n    ff:ff:ff:ff:ff:ff\
    \     1  static     -  -  0  1  2  3  4  5  6  7  8  9  a\n    root@infix-06-0b-00:~$\n\
    \nThe two IPv6 groups remain in the hardware database because the\nport (x3) is\
    \ notified of the host's membership twice: once via the\noriginal event and once\
    \ via a replay. Since only a single delete\nnotification is sent, the count remains\
    \ at 1 when the bridge is\ndestroyed.\n\nThen add the same port (or another port\
    \ belonging to the same hardware\ndomain) to a new bridge, this time with snooping\
    \ disabled:\n\n    root@infix-06-0b-00:~$ ip link add dev br1 up type bridge mcast_snooping\
    \ 0 && \\\n    > ip link set dev x3 up master br1\n\nAll multicast, including\
    \ the two IPv6 groups from br0, should now be\nflooded, according to the policy\
    \ of br1. But instead the old\nmemberships are still active in the hardware database,\
    \ causing the\nswitch to only forward traffic to those groups towards the CPU\
    \ (port\n0).\n\nEliminate the race in two steps:\n\n1. Grab the write-side lock\
    \ of the MDB while generating the replay\n   list.\n\nThis prevents new memberships\
    \ from showing up while we are generating\nthe replay list. But it leaves the\
    \ scenario in which a deferred event\nwas already generated, but not delivered,\
    \ before we grabbed the\nlock. Therefore:\n\n2. Make sure that no deferred version\
    \ of a replay event is already\n   enqueued to the switchdev deferred queue, before\
    \ adding it to the\n   replay list, when replaying additions."
- lang: es
  value: "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: net:\
    \ bridge: switchdev: omitir repeticiones MDB de eventos diferidos durante la descarga.\
    \ Antes de este cambio, la generaci\xF3n de la lista de eventos MDB para reproducir\
    \ competir\xEDa con la creaci\xF3n de nuevas membres\xEDas de grupos, ya sea desde\
    \ la l\xF3gica de espionaje IGMP/MLD o desde la configuraci\xF3n del usuario.\
    \ Si bien las nuevas membres\xEDas son visibles inmediatamente para los caminantes\
    \ de br-&gt;mdb_list, la notificaci\xF3n de su existencia a los suscriptores del\
    \ evento switchdev se difiere hasta un momento posterior. Entonces, si se gener\xF3\
    \ una lista de reproducci\xF3n durante un tiempo que se superpuso con dicha ventana,\
    \ tambi\xE9n contendr\xEDa una repetici\xF3n del evento a\xFAn no entregado. El\
    \ conductor recibir\xEDa as\xED dos copias de lo que internamente el puente consideraba\
    \ un \xFAnico evento. Por lo tanto, tras la destrucci\xF3n del puente, solo se\
    \ envi\xF3 un evento de eliminaci\xF3n de membres\xEDa. Como consecuencia de esto,\
    \ los controladores que hacen referencia al recuento de membres\xEDas (al menos\
    \ DSA) quedar\xEDan con grupos hu\xE9rfanos en su base de datos de hardware cuando\
    \ se destruyera el puente. Esto s\xF3lo es un problema al reproducir adiciones.\
    \ Si bien es posible que los eventos de eliminaci\xF3n a\xFAn est\xE9n pendientes\
    \ en la cola diferida, ya se habr\xE1n eliminado de br-&gt;mdb_list, por lo que\
    \ no se pueden generar duplicados en ese escenario. Para un usuario, esto significaba\
    \ que las antiguas membres\xEDas de grupos, de un puente al que previamente se\
    \ hab\xEDa conectado un puerto, pod\xEDan reanimarse (en hardware) cuando el puerto\
    \ se un\xEDa a un nuevo puente, sin el conocimiento del nuevo puente. Por ejemplo,\
    \ en un sistema mv88e6xxx, cree un puente de vigilancia e inmediatamente agr\xE9\
    guele un puerto: root@infix-06-0b-00:~$ ip link add dev br0 up type bridge mcast_snooping\
    \ 1 &amp;&amp; \\ &gt; ip link set dev x3 up master br0 Y luego destruye el puente:\
    \ root@infix-06-0b-00:~$ ip link del dev br0 root@infix-06-0b-00:~$ mvls atu DIRECCI\xD3\
    N FID ESTADO QF 0 1 2 3 4 5 6 7 8 9 a DEV:0 Marvell 88E6393X 33:33:00:00:00:6a\
    \ 1 est\xE1tico - - 0 . . . . . . . . . . 33:33:ff:87:e4:3f 1 est\xE1tico - -\
    \ 0 . . . . . . . . . . ff:ff:ff:ff:ff:ff 1 static - - 0 1 2 3 4 5 6 7 8 9 a root@infix-06-0b-00:~$\
    \ Los dos grupos IPv6 permanecen en la base de datos de hardware porque el puerto\
    \ (x3) recibe dos notificaciones sobre la membres\xEDa del anfitri\xF3n: una vez\
    \ a trav\xE9s del evento original y otra a trav\xE9s de una repetici\xF3n. Dado\
    \ que solo se env\xEDa una notificaci\xF3n de eliminaci\xF3n, el recuento permanece\
    \ en 1 cuando se destruye el puente. Luego agregue el mismo puerto (u otro puerto\
    \ que pertenezca al mismo dominio de hardware) a un nuevo puente, esta vez con\
    \ el snooping deshabilitado: root@infix-06-0b-00:~$ ip link add dev br1 up type\
    \ bridge mcast_snooping 0 &amp;&amp; \\ &gt; ip link set dev x3 up master br1\
    \ Toda la multidifusi\xF3n, incluidos los dos grupos IPv6 de br0, ahora deber\xED\
    a estar inundada, de acuerdo con la pol\xEDtica de br1. Pero, en cambio, las membres\xED\
    as antiguas todav\xEDa est\xE1n activas en la base de datos del hardware, lo que\
    \ hace que el conmutador solo reenv\xEDe el tr\xE1fico a esos grupos hacia la\
    \ CPU (puerto 0). Elimine la carrera en dos pasos: 1. Tome el bloqueo del lado\
    \ de escritura del MDB mientras genera la lista de reproducci\xF3n. Esto evita\
    \ que aparezcan nuevas membres\xEDas mientras generamos la lista de reproducci\xF3\
    n. Pero deja el escenario en el que ya se gener\xF3 un evento diferido, pero no\
    \ se entreg\xF3, antes de que tom\xE1ramos el bloqueo. Por lo tanto: 2. Aseg\xFA\
    rese de que ninguna versi\xF3n diferida de un evento de reproducci\xF3n ya est\xE9\
    \ en cola en la cola diferida de switchdev, antes de agregarla a la lista de reproducci\xF3\
    n, al reproducir adiciones."
id: CVE-2024-26837
lastModified: '2024-04-17T12:48:07.510'
metrics: {}
published: '2024-04-17T10:15:09.757'
references:
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/2d5b4b3376fa146a23917b8577064906d643925f
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/603be95437e7fd85ba694e75918067fb9e7754db
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/dc489f86257cab5056e747344f17a164f63bff4b
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/e0b4c5b1d760008f1dd18c07c35af0442e54f9c8
sourceIdentifier: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
vulnStatus: Awaiting Analysis
