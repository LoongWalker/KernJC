cveTags: []
descriptions:
- lang: en
  value: 'In the Linux kernel, the following vulnerability has been resolved:


    bpf: Defer work in bpf_timer_cancel_and_free


    Currently, the same case as previous patch (two timer callbacks trying

    to cancel each other) can be invoked through bpf_map_update_elem as

    well, or more precisely, freeing map elements containing timers. Since

    this relies on hrtimer_cancel as well, it is prone to the same deadlock

    situation as the previous patch.


    It would be sufficient to use hrtimer_try_to_cancel to fix this problem,

    as the timer cannot be enqueued after async_cancel_and_free. Once

    async_cancel_and_free has been done, the timer must be reinitialized

    before it can be armed again. The callback running in parallel trying to

    arm the timer will fail, and freeing bpf_hrtimer without waiting is

    sufficient (given kfree_rcu), and bpf_timer_cb will return

    HRTIMER_NORESTART, preventing the timer from being rearmed again.


    However, there exists a UAF scenario where the callback arms the timer

    before entering this function, such that if cancellation fails (due to

    timer callback invoking this routine, or the target timer callback

    running concurrently). In such a case, if the timer expiration is

    significantly far in the future, the RCU grace period expiration

    happening before it will free the bpf_hrtimer state and along with it

    the struct hrtimer, that is enqueued.


    Hence, it is clear cancellation needs to occur after

    async_cancel_and_free, and yet it cannot be done inline due to deadlock

    issues. We thus modify bpf_timer_cancel_and_free to defer work to the

    global workqueue, adding a work_struct alongside rcu_head (both used at

    _different_ points of time, so can share space).


    Update existing code comments to reflect the new state of affairs.'
- lang: es
  value: "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: bpf:\
    \ Aplazar el trabajo en bpf_timer_cancel_and_free Actualmente, el mismo caso del\
    \ parche anterior (dos devoluciones de llamada de temporizador que intentan cancelarse\
    \ entre s\xED) tambi\xE9n se puede invocar a trav\xE9s de bpf_map_update_elem,\
    \ o m\xE1s precisamente, liberando mapa elementos que contienen temporizadores.\
    \ Dado que esto tambi\xE9n depende de hrtimer_cancel, es propenso a la misma situaci\xF3\
    n de punto muerto que el parche anterior. Ser\xEDa suficiente usar hrtimer_try_to_cancel\
    \ para solucionar este problema, ya que el temporizador no se puede poner en cola\
    \ despu\xE9s de async_cancel_and_free. Una vez que se haya realizado async_cancel_and_free,\
    \ el temporizador debe reinicializarse antes de poder armarse nuevamente. La devoluci\xF3\
    n de llamada que se ejecuta en paralelo al intentar armar el temporizador fallar\xE1\
    , y liberar bpf_hrtimer sin esperar es suficiente (dado kfree_rcu), y bpf_timer_cb\
    \ devolver\xE1 HRTIMER_NORESTART, evitando que el temporizador se rearme nuevamente.\
    \ Sin embargo, existe un escenario UAF en el que la devoluci\xF3n de llamada arma\
    \ el temporizador antes de ingresar a esta funci\xF3n, de modo que si la cancelaci\xF3\
    n falla (debido a que la devoluci\xF3n de llamada del temporizador invoca esta\
    \ rutina o la devoluci\xF3n de llamada del temporizador de destino se ejecuta\
    \ simult\xE1neamente). En tal caso, si la expiraci\xF3n del temporizador est\xE1\
    \ significativamente lejos en el futuro, la expiraci\xF3n del per\xEDodo de gracia\
    \ de RCU que ocurra antes liberar\xE1 el estado bpf_hrtimer y junto con \xE9l\
    \ la estructura hrtimer, que est\xE1 en cola. Por lo tanto, est\xE1 claro que\
    \ la cancelaci\xF3n debe ocurrir despu\xE9s de async_cancel_and_free y, sin embargo,\
    \ no se puede realizar en l\xEDnea debido a problemas de interbloqueo. Por lo\
    \ tanto, modificamos bpf_timer_cancel_and_free para diferir el trabajo a la cola\
    \ de trabajo global, agregando un work_struct junto con rcu_head (ambos usados\
    \ en _diferentes_ puntos de tiempo, por lo que pueden compartir espacio). Actualice\
    \ los comentarios del c\xF3digo existente para reflejar la nueva situaci\xF3n."
id: CVE-2024-41045
lastModified: '2024-07-29T16:21:52.517'
metrics: {}
published: '2024-07-29T15:15:12.873'
references:
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/7aa5a19279c3639ae8b758b63f05d0c616a39fa1
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/a6fcd19d7eac1335eb76bc16b6a66b7f574d1d69
sourceIdentifier: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
vulnStatus: Awaiting Analysis
