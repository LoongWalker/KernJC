cveTags: []
descriptions:
- lang: en
  value: "In the Linux kernel, the following vulnerability has been resolved:\n\n\
    igc: avoid returning frame twice in XDP_REDIRECT\n\nWhen a frame can not be transmitted\
    \ in XDP_REDIRECT\n(e.g. due to a full queue), it is necessary to free\nit by\
    \ calling xdp_return_frame_rx_napi.\n\nHowever, this is the responsibility of\
    \ the caller of\nthe ndo_xdp_xmit (see for example bq_xmit_all in\nkernel/bpf/devmap.c)\
    \ and thus calling it inside\nigc_xdp_xmit (which is the ndo_xdp_xmit of the igc\n\
    driver) as well will lead to memory corruption.\n\nIn fact, bq_xmit_all expects\
    \ that it can return all\nframes after the last successfully transmitted one.\n\
    Therefore, break for the first not transmitted frame,\nbut do not call xdp_return_frame_rx_napi\
    \ in igc_xdp_xmit.\nThis is equally implemented in other Intel drivers\nsuch as\
    \ the igb.\n\nThere are two alternatives to this that were rejected:\n1. Return\
    \ num_frames as all the frames would have been\n   transmitted and release them\
    \ inside igc_xdp_xmit.\n   While it might work technically, it is not what\n \
    \  the return value is meant to represent (i.e. the\n   number of SUCCESSFULLY\
    \ transmitted packets).\n2. Rework kernel/bpf/devmap.c and all drivers to\n  \
    \ support non-consecutively dropped packets.\n   Besides being complex, it likely\
    \ has a negative\n   performance impact without a significant gain\n   since it\
    \ is anyway unlikely that the next frame\n   can be transmitted if the previous\
    \ one was dropped.\n\nThe memory corruption can be reproduced with\nthe following\
    \ script which leads to a kernel panic\nafter a few seconds.  It basically generates\
    \ more\ntraffic than a i225 NIC can transmit and pushes it\nvia XDP_REDIRECT from\
    \ a virtual interface to the\nphysical interface where frames get dropped.\n\n\
    \   #!/bin/bash\n   INTERFACE=enp4s0\n   INTERFACE_IDX=`cat /sys/class/net/$INTERFACE/ifindex`\n\
    \n   sudo ip link add dev veth1 type veth peer name veth2\n   sudo ip link set\
    \ up $INTERFACE\n   sudo ip link set up veth1\n   sudo ip link set up veth2\n\n\
    \   cat << EOF > redirect.bpf.c\n\n   SEC(\"prog\")\n   int redirect(struct xdp_md\
    \ *ctx)\n   {\n       return bpf_redirect($INTERFACE_IDX, 0);\n   }\n\n   char\
    \ _license[] SEC(\"license\") = \"GPL\";\n   EOF\n   clang -O2 -g -Wall -target\
    \ bpf -c redirect.bpf.c -o redirect.bpf.o\n   sudo ip link set veth2 xdp obj redirect.bpf.o\n\
    \n   cat << EOF > pass.bpf.c\n\n   SEC(\"prog\")\n   int pass(struct xdp_md *ctx)\n\
    \   {\n       return XDP_PASS;\n   }\n\n   char _license[] SEC(\"license\") =\
    \ \"GPL\";\n   EOF\n   clang -O2 -g -Wall -target bpf -c pass.bpf.c -o pass.bpf.o\n\
    \   sudo ip link set $INTERFACE xdp obj pass.bpf.o\n\n   cat << EOF > trafgen.cfg\n\
    \n   {\n     /* Ethernet Header */\n     0xe8, 0x6a, 0x64, 0x41, 0xbf, 0x46,\n\
    \     0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n     const16(ETH_P_IP),\n\n     /*\
    \ IPv4 Header */\n     0b01000101, 0,   # IPv4 version, IHL, TOS\n     const16(1028),\
    \   # IPv4 total length (UDP length + 20 bytes (IP header))\n     const16(2),\
    \      # IPv4 ident\n     0b01000000, 0,   # IPv4 flags, fragmentation off\n \
    \    64,              # IPv4 TTL\n     17,              # Protocol UDP\n     csumip(14,\
    \ 33),  # IPv4 checksum\n\n     /* UDP Header */\n     10,  0, 1, 1,    # IP Src\
    \ - adapt as needed\n     10,  0, 1, 2,    # IP Dest - adapt as needed\n     const16(6666),\
    \   # UDP Src Port\n     const16(6666),   # UDP Dest Port\n     const16(1008),\
    \   # UDP length (UDP header 8 bytes + payload length)\n     csumudp(14, 34),\
    \ # UDP checksum\n\n     /* Payload */\n     fill('W', 1000),\n   }\n   EOF\n\n\
    \   sudo trafgen -i trafgen.cfg -b3000MB -o veth1 --cpp"
- lang: es
  value: "En el kernel de Linux se ha resuelto la siguiente vulnerabilidad: igc: evita\
    \ devolver la trama dos veces en XDP_REDIRECT Cuando una trama no se puede transmitir\
    \ en XDP_REDIRECT (por ejemplo, debido a una cola llena), es necesario liberarla\
    \ llamando a xdp_return_frame_rx_napi. Sin embargo, esto es responsabilidad de\
    \ quien llama a ndo_xdp_xmit (ver, por ejemplo, bq_xmit_all en kernel/bpf/devmap.c)\
    \ y, por lo tanto, llamarlo dentro de igc_xdp_xmit (que es el ndo_xdp_xmit del\
    \ controlador igc) tambi\xE9n provocar\xE1 da\xF1os en la memoria. De hecho, bq_xmit_all\
    \ espera poder devolver todas las tramas despu\xE9s de la \xFAltima transmitida\
    \ con \xE9xito. Por lo tanto, interrumpa el primer cuadro no transmitido, pero\
    \ no llame a xdp_return_frame_rx_napi en igc_xdp_xmit. Esto se implementa igualmente\
    \ en otros controladores Intel como el igb. Hay dos alternativas a esto que fueron\
    \ rechazadas: 1. Devolver num_frames ya que se habr\xEDan transmitido todas las\
    \ tramas y liberarlas dentro de igc_xdp_xmit. Si bien podr\xEDa funcionar t\xE9\
    cnicamente, no es lo que debe representar el valor de retorno (es decir, el n\xFA\
    mero de paquetes transmitidos CON \xC9XITO). 2. Vuelva a trabajar kernel/bpf/devmap.c\
    \ y todos los controladores para admitir paquetes descartados no consecutivos.\
    \ Adem\xE1s de ser complejo, es probable que tenga un impacto negativo en el rendimiento\
    \ sin una ganancia significativa, ya que de todos modos es poco probable que se\
    \ pueda transmitir la siguiente trama si se elimin\xF3 la anterior. La corrupci\xF3\
    n de la memoria se puede reproducir con el siguiente script, lo que provoca un\
    \ p\xE1nico en el kernel despu\xE9s de unos segundos. B\xE1sicamente, genera m\xE1\
    s tr\xE1fico del que puede transmitir una NIC i225 y lo env\xEDa a trav\xE9s de\
    \ XDP_REDIRECT desde una interfaz virtual a la interfaz f\xEDsica donde se eliminan\
    \ las tramas. #!/bin/bash INTERFACE=enp4s0 INTERFACE_IDX=`cat /sys/class/net/$INTERFACE/ifindex`\
    \ sudo ip link agregar dev veth1 tipo veth nombre del par veth2 sudo ip link set\
    \ up $INTERFACE sudo ip link set up veth1 sudo enlace ip configurado veth2 cat\
    \ &lt;&lt; EOF &gt; redirecci\xF3n.bpf.c SEC(\"prog\") int redirecci\xF3n(struct\
    \ xdp_md *ctx) { return bpf_redirect($INTERFACE_IDX, 0); } char _license[] SEC(\"\
    licencia\") = \"GPL\"; EOF clang -O2 -g -Wall -target bpf -c redirecci\xF3n.bpf.c\
    \ -o redirecci\xF3n.bpf.o sudo ip link set veth2 xdp obj redirecci\xF3n.bpf.o\
    \ cat &lt;&lt; EOF &gt; pass.bpf.c SEC(\" prog\") int pass(struct xdp_md *ctx)\
    \ { return XDP_PASS; } char _license[] SEC(\"licencia\") = \"GPL\"; EOF clang\
    \ -O2 -g -Wall -target bpf -c pass.bpf.c -o pass.bpf.o sudo ip link set $INTERFACE\
    \ xdp obj pass.bpf.o cat &lt;&lt; EOF &gt; trafgen.cfg { /* Ethernet Encabezado\
    \ */ 0xe8, 0x6a, 0x64, 0x41, 0xbf, 0x46, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, const16(ETH_P_IP),\
    \ /* Encabezado IPv4 */ 0b01000101, 0, # Versi\xF3n IPv4, IHL, TOS const16 (1028),\
    \ # Longitud total de IPv4 (longitud UDP + 20 bytes (encabezado IP)) const16(2),\
    \ # Identificador de IPv4 0b01000000, 0, # Banderas de IPv4, fragmentaci\xF3n\
    \ desactivada 64, # IPv4 TTL 17, # Protocolo UDP csumip(14 , 33), # Suma de comprobaci\xF3\
    n IPv4 /* Encabezado UDP */ 10, 0, 1, 1, # IP Src - adaptar seg\xFAn sea necesario\
    \ 10, 0, 1, 2, # IP Dest - adaptar seg\xFAn sea necesario const16(6666), # UDP\
    \ Puerto Src const16(6666), # Puerto de destino UDP const16(1008), # Longitud\
    \ UDP (encabezado UDP 8 bytes + longitud de carga \xFAtil) csumudp(14, 34), #\
    \ Suma de comprobaci\xF3n UDP /* Carga \xFAtil */ fill('W', 1000 ), } EOF sudo\
    \ trafgen -i trafgen.cfg -b3000MB -o veth1 --cpp"
id: CVE-2024-26853
lastModified: '2024-04-17T12:48:07.510'
metrics: {}
published: '2024-04-17T11:15:08.583'
references:
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/1b3b8231386a572bac8cd5b6fd7e944b84f9bb1f
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/63a3c1f3c9ecc654d851e7906d05334cd0c236e2
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/8df393af9e7e8dfd62e9c41dbaa4d2ff53bf794a
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/ef27f655b438bed4c83680e4f01e1cde2739854b
sourceIdentifier: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
vulnStatus: Awaiting Analysis
