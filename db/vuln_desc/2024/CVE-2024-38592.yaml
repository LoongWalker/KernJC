cveTags: []
descriptions:
- lang: en
  value: 'In the Linux kernel, the following vulnerability has been resolved:


    drm/mediatek: Init `ddp_comp` with devm_kcalloc()


    In the case where `conn_routes` is true we allocate an extra slot in

    the `ddp_comp` array but mtk_drm_crtc_create() never seemed to

    initialize it in the test case I ran. For me, this caused a later

    crash when we looped through the array in mtk_drm_crtc_mode_valid().

    This showed up for me when I booted with `slub_debug=FZPUA` which

    poisons the memory initially. Without `slub_debug` I couldn''t

    reproduce, presumably because the later code handles the value being

    NULL and in most cases (not guaranteed in all cases) the memory the

    allocator returned started out as 0.


    It really doesn''t hurt to initialize the array with devm_kcalloc()

    since the array is small and the overhead of initting a handful of

    elements to 0 is small. In general initting memory to zero is a safer

    practice and usually it''s suggested to only use the non-initting alloc

    functions if you really need to.


    Let''s switch the function to use an allocation function that zeros the

    memory. For me, this avoids the crash.'
- lang: es
  value: "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: drm/mediatek:\
    \ Init `ddp_comp` con devm_kcalloc() En el caso de que `conn_routes` sea verdadero,\
    \ asignamos una ranura adicional en la matriz `ddp_comp` pero mtk_drm_crtc_create()\
    \ nunca apareci\xF3 para inicializarlo en el caso de prueba que ejecut\xE9. Para\
    \ m\xED, esto provoc\xF3 un bloqueo posterior cuando recorrimos la matriz en mtk_drm_crtc_mode_valid().\
    \ Esto me apareci\xF3 cuando arranqu\xE9 con `slub_debug=FZPUA` que envenena la\
    \ memoria inicialmente. Sin `slub_debug` no pude reproducir, presumiblemente porque\
    \ el c\xF3digo posterior maneja que el valor sea NULL y en la mayor\xEDa de los\
    \ casos (no garantizado en todos los casos) la memoria que devolvi\xF3 el asignador\
    \ comenz\xF3 como 0. Realmente no est\xE1 de m\xE1s inicializar el array con devm_kcalloc()\
    \ ya que la matriz es peque\xF1a y la sobrecarga de iniciar un pu\xF1ado de elementos\
    \ en 0 es peque\xF1a. En general, iniciar la memoria a cero es una pr\xE1ctica\
    \ m\xE1s segura y, por lo general, se sugiere usar solo las funciones de asignaci\xF3\
    n que no son de inicio si realmente es necesario. Cambiemos la funci\xF3n para\
    \ usar una funci\xF3n de asignaci\xF3n que ponga a cero la memoria. Para m\xED\
    , esto evita el accidente."
id: CVE-2024-38592
lastModified: '2024-06-20T12:44:01.637'
metrics: {}
published: '2024-06-19T14:15:19.297'
references:
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/01a2c5123e27b3c4685bf2fc4c2e879f6e0c7b33
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/9fe2cc3fa44f7ad7ba5f29c1a68b2b924c17b9b1
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/cf69d0af7db917b82aceaa44b7b1b9376609da22
sourceIdentifier: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
vulnStatus: Awaiting Analysis
