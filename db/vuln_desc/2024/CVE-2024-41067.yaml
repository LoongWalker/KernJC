cveTags: []
descriptions:
- lang: en
  value: "In the Linux kernel, the following vulnerability has been resolved:\n\n\
    btrfs: scrub: handle RST lookup error correctly\n\n[BUG]\nWhen running btrfs/060\
    \ with forced RST feature, it would crash the\nfollowing ASSERT() inside scrub_read_endio():\n\
    \n\tASSERT(sector_nr < stripe->nr_sectors);\n\nBefore that, we would have tree\
    \ dump from\nbtrfs_get_raid_extent_offset(), as we failed to find the RST entry\
    \ for\nthe range.\n\n[CAUSE]\nInside scrub_submit_extent_sector_read() every time\
    \ we allocated a new\nbbio we immediately called btrfs_map_block() to make sure\
    \ there was some\nRST range covering the scrub target.\n\nBut if btrfs_map_block()\
    \ fails, we immediately call endio for the bbio,\nwhile the bbio is newly allocated,\
    \ it's completely empty.\n\nThen inside scrub_read_endio(), we go through the\
    \ bvecs to find\nthe sector number (as bi_sector is no longer reliable if the\
    \ bio is\nsubmitted to lower layers).\n\nAnd since the bio is empty, such bvecs\
    \ iteration would not find any\nsector matching the sector, and return sector_nr\
    \ == stripe->nr_sectors,\ntriggering the ASSERT().\n\n[FIX]\nInstead of calling\
    \ btrfs_map_block() after allocating a new bbio, call\nbtrfs_map_block() first.\n\
    \nSince our only objective of calling btrfs_map_block() is only to update\nstripe_len,\
    \ there is really no need to do that after btrfs_alloc_bio().\n\nThis new timing\
    \ would avoid the problem of handling empty bbio\ncompletely, and in fact fixes\
    \ a possible race window for the old code,\nwhere if the submission thread is\
    \ the only owner of the pending_io, the\nscrub would never finish (since we didn't\
    \ decrease the pending_io\ncounter).\n\nAlthough the root cause of RST lookup\
    \ failure still needs to be\naddressed."
- lang: es
  value: "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: btrfs:\
    \ Scrub: maneja correctamente el error de b\xFAsqueda RST [ERROR] Al ejecutar\
    \ btrfs/060 con la funci\xF3n RST forzada, bloquear\xEDa el siguiente ASSERT()\
    \ dentro de Scrub_read_endio(): ASSERT(sector_nr &lt; raya-&gt;nr_sectors); Antes\
    \ de eso, tendr\xEDamos un volcado de \xE1rbol de btrfs_get_raid_extent_offset(),\
    \ ya que no pudimos encontrar la entrada RST para el rango. [CAUSA] Dentro de\
    \ Scrub_submit_extent_sector_read() cada vez que asignamos un nuevo bbio llamamos\
    \ inmediatamente a btrfs_map_block() para asegurarnos de que hubiera alg\xFAn\
    \ rango RST que cubriera el objetivo de limpieza. Pero si btrfs_map_block()fallo,\
    \ inmediatamente llamamos a endio para el bbio, mientras el bbio est\xE1 reci\xE9\
    n asignado, est\xE1 completamente vac\xEDo. Luego, dentro de Scrub_read_endio(),\
    \ revisamos los bvecs para encontrar el n\xFAmero del sector (ya que bi_sector\
    \ ya no es confiable si la biograf\xEDa se env\xEDa a capas inferiores). Y dado\
    \ que la biograf\xEDa est\xE1 vac\xEDa, dicha iteraci\xF3n de bvecs no encontrar\xED\
    a ning\xFAn sector que coincida con el sector y devolver\xEDa sector_nr == stripe-&gt;nr_sectors,\
    \ lo que activar\xEDa ASSERT(). [FIX] En lugar de llamar a btrfs_map_block() despu\xE9\
    s de asignar un nuevo bbio, llame primero a btrfs_map_block(). Dado que nuestro\
    \ \xFAnico objetivo al llamar a btrfs_map_block() es solo actualizar stripe_len,\
    \ realmente no hay necesidad de hacerlo despu\xE9s de btrfs_alloc_bio(). Este\
    \ nuevo tiempo evitar\xEDa por completo el problema de manejar bbio vac\xEDo y,\
    \ de hecho, soluciona una posible ventana de ejecuci\xF3npara el c\xF3digo anterior,\
    \ donde si el hilo de env\xEDo es el \xFAnico propietario de pendiente_io, la\
    \ limpieza nunca terminar\xEDa (ya que no lo hicimos). disminuir el contador pendiente_io).\
    \ Aunque a\xFAn es necesario abordar la causa ra\xEDz del error de b\xFAsqueda\
    \ de RST."
id: CVE-2024-41067
lastModified: '2024-07-29T16:21:52.517'
metrics: {}
published: '2024-07-29T15:15:14.560'
references:
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/17d1fd302a53d7e456a7412da74be74a0cf63a72
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/2c49908634a2b97b1c3abe0589be2739ac5e7fd5
sourceIdentifier: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
vulnStatus: Awaiting Analysis
