descriptions:
- lang: en
  value: 'In the Linux kernel, the following vulnerability has been resolved:


    mm, kmsan: fix infinite recursion due to RCU critical section


    Alexander Potapenko writes in [1]: "For every memory access in the code

    instrumented by KMSAN we call kmsan_get_metadata() to obtain the metadata

    for the memory being accessed.  For virtual memory the metadata pointers

    are stored in the corresponding `struct page`, therefore we need to call

    virt_to_page() to get them.


    According to the comment in arch/x86/include/asm/page.h,

    virt_to_page(kaddr) returns a valid pointer iff virt_addr_valid(kaddr) is

    true, so KMSAN needs to call virt_addr_valid() as well.


    To avoid recursion, kmsan_get_metadata() must not call instrumented code,

    therefore ./arch/x86/include/asm/kmsan.h forks parts of

    arch/x86/mm/physaddr.c to check whether a virtual address is valid or not.


    But the introduction of rcu_read_lock() to pfn_valid() added instrumented

    RCU API calls to virt_to_page_or_null(), which is called by

    kmsan_get_metadata(), so there is an infinite recursion now.  I do not

    think it is correct to stop that recursion by doing

    kmsan_enter_runtime()/kmsan_exit_runtime() in kmsan_get_metadata(): that

    would prevent instrumented functions called from within the runtime from

    tracking the shadow values, which might introduce false positives."


    Fix the issue by switching pfn_valid() to the _sched() variant of

    rcu_read_lock/unlock(), which does not require calling into RCU.  Given

    the critical section in pfn_valid() is very small, this is a reasonable

    trade-off (with preemptible RCU).


    KMSAN further needs to be careful to suppress calls into the scheduler,

    which would be another source of recursion.  This can be done by wrapping

    the call to pfn_valid() into preempt_disable/enable_no_resched().  The

    downside is that this sacrifices breaking scheduling guarantees; however,

    a kernel compiled with KMSAN has already given up any performance

    guarantees due to being heavily instrumented.


    Note, KMSAN code already disables tracing via Makefile, and since mmzone.h

    is included, it is not necessary to use the notrace variant, which is

    generally preferred in all other cases.'
- lang: es
  value: "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: mm, kmsan:\
    \ corrige la recursividad infinita debido a la secci\xF3n cr\xEDtica de RCU Alexander\
    \ Potapenko escribe en [1]: \"Para cada acceso a memoria en el c\xF3digo instrumentado\
    \ por KMSAN llamamos kmsan_get_metadata() para obtener los metadatos de la memoria\
    \ a la que se accede. Para la memoria virtual, los punteros de metadatos se almacenan\
    \ en la `p\xE1gina de estructura` correspondiente, por lo tanto, necesitamos llamar\
    \ a virt_to_page() para obtenerlos. De acuerdo con el comentario en arch/x86/include/asm/page\
    \ .h, virt_to_page(kaddr) devuelve un puntero v\xE1lido si virt_addr_valid(kaddr)\
    \ es verdadero, por lo que KMSAN tambi\xE9n necesita llamar a virt_addr_valid().\
    \ Para evitar la recursividad, kmsan_get_metadata() no debe llamar al c\xF3digo\
    \ instrumentado, por lo tanto ./arch/x86/ include/asm/kmsan.h bifurca partes de\
    \ arch/x86/mm/physaddr.c para verificar si una direcci\xF3n virtual es v\xE1lida\
    \ o no, pero la introducci\xF3n de rcu_read_lock() a pfn_valid() agreg\xF3 llamadas\
    \ API de RCU instrumentadas a virt_to_page_or_null() , que es llamado por kmsan_get_metadata(),\
    \ por lo que ahora hay una recursividad infinita. No creo que sea correcto detener\
    \ esa recursividad haciendo kmsan_enter_runtime()/kmsan_exit_runtime() en kmsan_get_metadata():\
    \ eso evitar\xEDa que las funciones instrumentadas llamadas desde el tiempo de\
    \ ejecuci\xF3n rastreen los valores ocultos, lo que podr\xEDa introducir falsos\
    \ positivos. problema al cambiar pfn_valid() a la variante _sched() de rcu_read_lock/unlock(),\
    \ que no requiere llamar a RCU. Dado que la secci\xF3n cr\xEDtica en pfn_valid()\
    \ es muy peque\xF1a, esta es una compensaci\xF3n razonable (con RCU interrumpible\
    \ ). Adem\xE1s, KMSAN debe tener cuidado de suprimir las llamadas al programador,\
    \ lo que ser\xEDa otra fuente de recursividad. Esto se puede hacer envolviendo\
    \ la llamada a pfn_valid() en preempt_disable/enable_no_resched(). La desventaja\
    \ es que esto sacrifica la interrupci\xF3n de la programaci\xF3n. garant\xEDas;\
    \ sin embargo, un kernel compilado con KMSAN ya ha renunciado a cualquier garant\xED\
    a de rendimiento debido a que est\xE1 fuertemente instrumentado. Tenga en cuenta\
    \ que el c\xF3digo KMSAN ya deshabilita el seguimiento a trav\xE9s de Makefile\
    \ y, dado que mmzone.h est\xE1 incluido, no es necesario usar la variante notrace,\
    \ que generalmente se prefiere en todos los dem\xE1s casos."
id: CVE-2024-26639
lastModified: '2024-04-04T14:15:09.457'
metrics: {}
published: '2024-03-18T11:15:10.880'
references:
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/5a33420599fa0288792537e6872fd19cc8607ea6
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/6335c0cdb2ea0ea02c999e04d34fd84f69fb27ff
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/dc904345e3771aa01d0b8358b550802fdc6fe00b
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/f6564fce256a3944aa1bc76cb3c40e792d97c1eb
sourceIdentifier: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
vulnStatus: Awaiting Analysis
