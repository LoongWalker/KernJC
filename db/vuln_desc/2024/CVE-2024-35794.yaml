descriptions:
- lang: en
  value: "In the Linux kernel, the following vulnerability has been resolved:\n\n\
    dm-raid: really frozen sync_thread during suspend\n\n1) commit f52f5c71f3d4 (\"\
    md: fix stopping sync thread\") remove\n   MD_RECOVERY_FROZEN from __md_stop_writes()\
    \ and doesn't realize that\n   dm-raid relies on __md_stop_writes() to frozen\
    \ sync_thread\n   indirectly. Fix this problem by adding MD_RECOVERY_FROZEN in\n\
    \   md_stop_writes(), and since stop_sync_thread() is only used for\n   dm-raid\
    \ in this case, also move stop_sync_thread() to\n   md_stop_writes().\n2) The\
    \ flag MD_RECOVERY_FROZEN doesn't mean that sync thread is frozen,\n   it only\
    \ prevent new sync_thread to start, and it can't stop the\n   running sync thread;\
    \ In order to frozen sync_thread, after seting the\n   flag, stop_sync_thread()\
    \ should be used.\n3) The flag MD_RECOVERY_FROZEN doesn't mean that writes are\
    \ stopped, use\n   it as condition for md_stop_writes() in raid_postsuspend()\
    \ doesn't\n   look correct. Consider that reentrant stop_sync_thread() do nothing,\n\
    \   always call md_stop_writes() in raid_postsuspend().\n4) raid_message can set/clear\
    \ the flag MD_RECOVERY_FROZEN at anytime,\n   and if MD_RECOVERY_FROZEN is cleared\
    \ while the array is suspended,\n   new sync_thread can start unexpected. Fix\
    \ this by disallow\n   raid_message() to change sync_thread status during suspend.\n\
    \nNote that after commit f52f5c71f3d4 (\"md: fix stopping sync thread\"), the\n\
    test shell/lvconvert-raid-reshape.sh start to hang in stop_sync_thread(),\nand\
    \ with previous fixes, the test won't hang there anymore, however, the\ntest will\
    \ still fail and complain that ext4 is corrupted. And with this\npatch, the test\
    \ won't hang due to stop_sync_thread() or fail due to ext4\nis corrupted anymore.\
    \ However, there is still a deadlock related to\ndm-raid456 that will be fixed\
    \ in following patches."
- lang: es
  value: "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: dm-raid:\
    \ sync_thread realmente congelado durante la suspensi\xF3n 1) commit f52f5c71f3d4\
    \ (\"md: fix deteniendo el hilo de sincronizaci\xF3n\") elimina MD_RECOVERY_FROZEN\
    \ de __md_stop_writes() y no se da cuenta de que dm-raid se basa en __md_stop_writes()\
    \ para congelar sync_thread indirectamente. Solucione este problema agregando\
    \ MD_RECOVERY_FROZEN en md_stop_writes(), y dado que stop_sync_thread() solo se\
    \ usa para dm-raid en este caso, mueva tambi\xE9n stop_sync_thread() a md_stop_writes().\
    \ 2) La bandera MD_RECOVERY_FROZEN no significa que el subproceso de sincronizaci\xF3\
    n est\xE9 congelado, solo impide que se inicie un nuevo subproceso de sincronizaci\xF3\
    n y no puede detener el subproceso de sincronizaci\xF3n en ejecuci\xF3n; Para\
    \ congelar sync_thread, despu\xE9s de configurar la bandera, se debe usar stop_sync_thread().\
    \ 3) La bandera MD_RECOVERY_FROZEN no significa que se detengan las escrituras;\
    \ usarla como condici\xF3n para md_stop_writes() en raid_postsuspend() no parece\
    \ correcta. Considere que el reentrante stop_sync_thread() no hace nada, siempre\
    \ llame a md_stop_writes() en raid_postsuspend(). 4) raid_message puede establecer/borrar\
    \ el indicador MD_RECOVERY_FROZEN en cualquier momento, y si MD_RECOVERY_FROZEN\
    \ se borra mientras la matriz est\xE1 suspendida, un nuevo sync_thread puede iniciarse\
    \ inesperadamente. Solucione este problema al no permitir que raid_message() cambie\
    \ el estado de sync_thread durante la suspensi\xF3n. Tenga en cuenta que despu\xE9\
    s de confirmar f52f5c71f3d4 (\"md: arreglar la detenci\xF3n del hilo de sincronizaci\xF3\
    n\"), la prueba shell/lvconvert-raid-reshape.sh comienza a bloquearse en stop_sync_thread(),\
    \ y con las correcciones anteriores, la prueba ya no se bloquear\xE1 all\xED,\
    \ sin embargo , la prueba seguir\xE1 fallondo y se quejar\xE1 de que ext4 est\xE1\
    \ da\xF1ado. Y con este parche, la prueba no se bloquear\xE1 debido a stop_sync_thread()\
    \ ni fallar\xE1 debido a que ext4 ya est\xE1 da\xF1ado. Sin embargo, todav\xED\
    a hay un punto muerto relacionado con dm-raid456 que se solucionar\xE1 en los\
    \ siguientes parches."
id: CVE-2024-35794
lastModified: '2024-05-17T18:35:35.070'
metrics: {}
published: '2024-05-17T13:15:59.097'
references:
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/16c4770c75b1223998adbeb7286f9a15c65fba73
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/af916cb66a80597f3523bc85812e790bcdcfd62b
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/eaa8fc9b092837cf2c754bde1a15d784ce9a85ab
sourceIdentifier: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
vulnStatus: Awaiting Analysis
