descriptions:
- lang: en
  value: 'In the Linux kernel, the following vulnerability has been resolved:


    firewire: ohci: mask bus reset interrupts between ISR and bottom half


    In the FireWire OHCI interrupt handler, if a bus reset interrupt has

    occurred, mask bus reset interrupts until bus_reset_work has serviced and

    cleared the interrupt.


    Normally, we always leave bus reset interrupts masked. We infer the bus

    reset from the self-ID interrupt that happens shortly thereafter. A

    scenario where we unmask bus reset interrupts was introduced in 2008 in

    a007bb857e0b26f5d8b73c2ff90782d9c0972620: If

    OHCI_PARAM_DEBUG_BUSRESETS (8) is set in the debug parameter bitmask, we

    will unmask bus reset interrupts so we can log them.


    irq_handler logs the bus reset interrupt. However, we can''t clear the bus

    reset event flag in irq_handler, because we won''t service the event until

    later. irq_handler exits with the event flag still set. If the

    corresponding interrupt is still unmasked, the first bus reset will

    usually freeze the system due to irq_handler being called again each

    time it exits. This freeze can be reproduced by loading firewire_ohci

    with "modprobe firewire_ohci debug=-1" (to enable all debugging output).

    Apparently there are also some cases where bus_reset_work will get called

    soon enough to clear the event, and operation will continue normally.


    This freeze was first reported a few months after a007bb85 was committed,

    but until now it was never fixed. The debug level could safely be set

    to -1 through sysfs after the module was loaded, but this would be

    ineffectual in logging bus reset interrupts since they were only

    unmasked during initialization.


    irq_handler will now leave the event flag set but mask bus reset

    interrupts, so irq_handler won''t be called again and there will be no

    freeze. If OHCI_PARAM_DEBUG_BUSRESETS is enabled, bus_reset_work will

    unmask the interrupt after servicing the event, so future interrupts

    will be caught as desired.


    As a side effect to this change, OHCI_PARAM_DEBUG_BUSRESETS can now be

    enabled through sysfs in addition to during initial module loading.

    However, when enabled through sysfs, logging of bus reset interrupts will

    be effective only starting with the second bus reset, after

    bus_reset_work has executed.'
- lang: es
  value: "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: firewire:\
    \ ohci: enmascara las interrupciones de reinicio del bus entre ISR y la mitad\
    \ inferior. En el controlador de interrupciones FireWire OHCI, si se ha producido\
    \ una interrupci\xF3n de reinicio del bus, enmascara las interrupciones de reinicio\
    \ del bus hasta que bus_reset_work haya sido reparado y borrado la interrupci\xF3\
    n. Normalmente, siempre dejamos enmascaradas las interrupciones de reinicio del\
    \ bus. Inferimos el reinicio del bus a partir de la interrupci\xF3n de la autoidentificaci\xF3\
    n que ocurre poco despu\xE9s. En 2008 se introdujo un escenario en el que desenmascaramos\
    \ las interrupciones de reinicio del bus en a007bb857e0b26f5d8b73c2ff90782d9c0972620:\
    \ Si OHCI_PARAM_DEBUG_BUSRESETS (8) est\xE1 configurado en la m\xE1scara de bits\
    \ del par\xE1metro de depuraci\xF3n, desenmascararemos las interrupciones de reinicio\
    \ del bus para poder registrarlas. irq_handler registra la interrupci\xF3n de\
    \ reinicio del bus. Sin embargo, no podemos borrar el indicador de evento de reinicio\
    \ del bus en irq_handler porque no atenderemos el evento hasta m\xE1s tarde. irq_handler\
    \ sale con el indicador de evento a\xFAn configurado. Si la interrupci\xF3n correspondiente\
    \ a\xFAn est\xE1 desenmascarada, el primer reinicio del bus generalmente congelar\xE1\
    \ el sistema debido a que se vuelve a llamar a irq_handler cada vez que sale.\
    \ Esta congelaci\xF3n se puede reproducir cargando firewire_ohci con \"modprobe\
    \ firewire_ohci debug=-1\" (para habilitar todos los resultados de depuraci\xF3\
    n). Aparentemente, tambi\xE9n hay algunos casos en los que se llamar\xE1 a bus_reset_work\
    \ lo suficientemente pronto como para borrar el evento y la operaci\xF3n continuar\xE1\
    \ normalmente. Esta congelaci\xF3n se inform\xF3 por primera vez unos meses despu\xE9\
    s del commit a007bb85, pero hasta ahora nunca se hab\xEDa solucionado. El nivel\
    \ de depuraci\xF3n podr\xEDa establecerse de forma segura en -1 a trav\xE9s de\
    \ sysfs despu\xE9s de cargar el m\xF3dulo, pero esto ser\xEDa ineficaz para registrar\
    \ las interrupciones de reinicio del bus ya que s\xF3lo se desenmascararon durante\
    \ la inicializaci\xF3n. irq_handler ahora dejar\xE1 establecido el indicador de\
    \ evento pero enmascarar\xE1 las interrupciones de reinicio del bus, por lo que\
    \ no se volver\xE1 a llamar a irq_handler y no se congelar\xE1. Si OHCI_PARAM_DEBUG_BUSRESETS\
    \ est\xE1 habilitado, bus_reset_work desenmascarar\xE1 la interrupci\xF3n despu\xE9\
    s de atender el evento, por lo que las interrupciones futuras se detectar\xE1\
    n seg\xFAn se desee. Como efecto secundario de este cambio, OHCI_PARAM_DEBUG_BUSRESETS\
    \ ahora se puede habilitar a trav\xE9s de sysfs adem\xE1s de durante la carga\
    \ inicial del m\xF3dulo. Sin embargo, cuando se habilita a trav\xE9s de sysfs,\
    \ el registro de interrupciones de reinicio del bus ser\xE1 efectivo solo a partir\
    \ del segundo reinicio del bus, despu\xE9s de que se haya ejecutado bus_reset_work."
id: CVE-2024-36950
lastModified: '2024-05-30T18:18:58.870'
metrics: {}
published: '2024-05-30T16:15:18.000'
references:
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/31279bbca40d2f40cb3bbb6d538ec9620a645dec
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/4f9cc355c328fc4f41cbd9c4cd58b235184fa420
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/5982887de60c1b84f9c0ca07c835814d07fd1da0
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/6fafe3661712b143d9c69a7322294bd53f559d5d
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/752e3c53de0fa3b7d817a83050b6699b8e9c6ec9
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/8643332aac0576581cfdf01798ea3e4e0d624b61
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/b3948c69d60279fce5b2eeda92a07d66296c8130
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/fa273f312334246c909475c5868e6daab889cc8c
sourceIdentifier: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
vulnStatus: Awaiting Analysis
