configurations:
- nodes:
  - cpeMatch:
    - criteria: cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*
      matchCriteriaId: D074AE50-4A5E-499C-A2FD-75FD60DEA560
      versionEndExcluding: 6.10.5
      versionStartIncluding: '6.7'
      vulnerable: true
    - criteria: cpe:2.3:o:linux:linux_kernel:6.11:rc1:*:*:*:*:*:*
      matchCriteriaId: 8B3CE743-2126-47A3-8B7C-822B502CF119
      vulnerable: true
    - criteria: cpe:2.3:o:linux:linux_kernel:6.11:rc2:*:*:*:*:*:*
      matchCriteriaId: 4DEB27E7-30AA-45CC-8934-B89263EF3551
      vulnerable: true
    negate: false
    operator: OR
cveTags: []
descriptions:
- lang: en
  value: 'In the Linux kernel, the following vulnerability has been resolved:


    idpf: fix memory leaks and crashes while performing a soft reset


    The second tagged commit introduced a UAF, as it removed restoring

    q_vector->vport pointers after reinitializating the structures.

    This is due to that all queue allocation functions are performed here

    with the new temporary vport structure and those functions rewrite

    the backpointers to the vport. Then, this new struct is freed and

    the pointers start leading to nowhere.


    But generally speaking, the current logic is very fragile. It claims

    to be more reliable when the system is low on memory, but in fact, it

    consumes two times more memory as at the moment of running this

    function, there are two vports allocated with their queues and vectors.

    Moreover, it claims to prevent the driver from running into "bad state",

    but in fact, any error during the rebuild leaves the old vport in the

    partially allocated state.

    Finally, if the interface is down when the function is called, it always

    allocates a new queue set, but when the user decides to enable the

    interface later on, vport_open() allocates them once again, IOW there''s

    a clear memory leak here.


    Just don''t allocate a new queue set when performing a reset, that solves

    crashes and memory leaks. Readd the old queue number and reopen the

    interface on rollback - that solves limbo states when the device is left

    disabled and/or without HW queues enabled.'
- lang: es
  value: "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: idpf:\
    \ corrige fugas de memoria y fallos al realizar un reinicio suave El segundo commit\
    \ etiquetado introdujo un UAF, ya que elimin\xF3 la restauraci\xF3n de punteros\
    \ q_vector-&gt;vport despu\xE9s de reinicializar las estructuras. Esto se debe\
    \ a que todas las funciones de asignaci\xF3n de colas se realizan aqu\xED con\
    \ la nueva estructura vport temporal y esas funciones reescriben los punteros\
    \ hacia atr\xE1s al vport. Luego, esta nueva estructura se libera y los punteros\
    \ comienzan a no llevar a ninguna parte. Pero en t\xE9rminos generales, la l\xF3\
    gica actual es muy fr\xE1gil. Afirma ser m\xE1s confiable cuando el sistema tiene\
    \ poca memoria, pero de hecho, consume dos veces m\xE1s memoria ya que en el momento\
    \ de ejecutar esta funci\xF3n, hay dos vports asignados con sus colas y vectores.\
    \ Adem\xE1s, afirma evitar que el controlador entre en \"mal estado\", pero de\
    \ hecho, cualquier error durante la reconstrucci\xF3n deja el antiguo vport en\
    \ el estado parcialmente asignado. Finalmente, si la interfaz est\xE1 inactiva\
    \ cuando se llama a la funci\xF3n, siempre asigna un nuevo conjunto de colas,\
    \ pero cuando el usuario decide habilitar la interfaz m\xE1s adelante, vport_open()\
    \ las asigna una vez m\xE1s, es decir, hay una clara p\xE9rdida de memoria aqu\xED\
    . Simplemente no asigne un nuevo conjunto de colas cuando realice un reinicio,\
    \ eso resuelve fallas y p\xE9rdidas de memoria. Vuelva a agregar el n\xFAmero\
    \ de cola anterior y vuelva a abrir la interfaz en la reversi\xF3n: eso resuelve\
    \ los estados de limbo cuando el dispositivo se deja deshabilitado y/o sin colas\
    \ de HW habilitadas."
id: CVE-2024-44964
lastModified: '2024-09-06T16:36:45.137'
metrics:
  cvssMetricV31:
  - cvssData:
      attackComplexity: LOW
      attackVector: LOCAL
      availabilityImpact: HIGH
      baseScore: 7.8
      baseSeverity: HIGH
      confidentialityImpact: HIGH
      integrityImpact: HIGH
      privilegesRequired: LOW
      scope: UNCHANGED
      userInteraction: NONE
      vectorString: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
      version: '3.1'
    exploitabilityScore: 1.8
    impactScore: 5.9
    source: nvd@nist.gov
    type: Primary
published: '2024-09-04T19:15:30.940'
references:
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  tags:
  - Patch
  url: https://git.kernel.org/stable/c/6b289f8d91537ec1e4f9c7b38b31b90d93b1419b
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  tags:
  - Patch
  url: https://git.kernel.org/stable/c/f01032a2ca099ec8d619aaa916c3762aa62495df
sourceIdentifier: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
vulnStatus: Analyzed
weaknesses:
- description:
  - lang: en
    value: CWE-401
  - lang: en
    value: CWE-416
  source: nvd@nist.gov
  type: Primary
