cveTags: []
descriptions:
- lang: en
  value: 'In the Linux kernel, the following vulnerability has been resolved:


    media: stk1160: fix bounds checking in stk1160_copy_video()


    The subtract in this condition is reversed.  The ->length is the length

    of the buffer.  The ->bytesused is how many bytes we have copied thus

    far.  When the condition is reversed that means the result of the

    subtraction is always negative but since it''s unsigned then the result

    is a very high positive value.  That means the overflow check is never

    true.


    Additionally, the ->bytesused doesn''t actually work for this purpose

    because we''re not writing to "buf->mem + buf->bytesused".  Instead, the

    math to calculate the destination where we are writing is a bit

    involved.  You calculate the number of full lines already written,

    multiply by two, skip a line if necessary so that we start on an odd

    numbered line, and add the offset into the line.


    To fix this buffer overflow, just take the actual destination where we

    are writing, if the offset is already out of bounds print an error and

    return.  Otherwise, write up to buf->length bytes.'
- lang: es
  value: "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: medios:\
    \ stk1160: revisi\xF3n de los l\xEDmites fijos en stk1160_copy_video() La resta\
    \ en esta condici\xF3n se invierte. La -&gt;longitud es la longitud del b\xFA\
    fer. El -&gt;byteused es cu\xE1ntos bytes hemos copiado hasta ahora. Cuando la\
    \ condici\xF3n se invierte, eso significa que el resultado de la resta siempre\
    \ es negativo, pero como no tiene signo, el resultado es un valor positivo muy\
    \ alto. Eso significa que la verificaci\xF3n de desbordamiento nunca es cierta.\
    \ Adem\xE1s, -&gt;bytesused en realidad no funciona para este prop\xF3sito porque\
    \ no estamos escribiendo en \"buf-&gt;mem + buf-&gt;bytesused\". En cambio, las\
    \ matem\xE1ticas para calcular el destino donde estamos escribiendo son un poco\
    \ complicadas. Calcula el n\xFAmero de l\xEDneas completas ya escritas, multiplica\
    \ por dos, omite una l\xEDnea si es necesario para comenzar en una l\xEDnea impar\
    \ y agrega el desplazamiento a la l\xEDnea. Para solucionar este desbordamiento\
    \ del b\xFAfer, simplemente tome el destino real donde estamos escribiendo, si\
    \ el desplazamiento ya est\xE1 fuera de los l\xEDmites imprima un error y regrese.\
    \ De lo contrario, escriba hasta buf-&gt;bytes de longitud."
id: CVE-2024-38621
lastModified: '2024-07-15T07:15:13.207'
metrics: {}
published: '2024-06-21T11:15:11.103'
references:
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/7532bcec0797adfa08791301c3bcae14141db3bd
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/a08492832cc4cacc24e0612f483c86ca899b9261
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/a16775828aaed1c54ff4e6fe83e8e4d5c6a50cb7
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/b504518a397059e1d55c521ba0ea2b545a6c4b52
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/d410017a7181cb55e4a5c810b32b75e4416c6808
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/ecf4ddc3aee8ade504c4d36b7b4053ce6093e200
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/f6a392266276730bea893b55d12940e32a25f56a
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/faa4364bef2ec0060de381ff028d1d836600a381
sourceIdentifier: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
vulnStatus: Awaiting Analysis
