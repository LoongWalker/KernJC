// https://github.com/linux-test-project/ltp/issues/592
//#include <stddef.h>
//#include <sound/asound.h>
//#include <sound/asequencer.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/ioctl.h>
#include <errno.h>
#include <stdio.h>
#include <fcntl.h>
#include <pthread.h>
#include <stdio.h>

#define SNDRV_SEQ_IOCTL_PVERSION        _IOR ('S', 0x00, int)
#define SNDRV_SEQ_IOCTL_CLIENT_ID       _IOR ('S', 0x01, int)

struct snd_seq_addr {
         unsigned char client;   /**< Client number:         0..255, 255 = br    oadcast to all clients */
         unsigned char port;     /**< Port within client:    0..255, 255 = br    oadcast to all ports */
};

struct snd_seq_port_info {
         struct snd_seq_addr addr;       /* client/port numbers */
         char name[64];                  /* port name */

         unsigned int capability;        /* port capability bits */
         unsigned int type;              /* port type bits */
         int midi_channels;              /* channels per MIDI port */
         int midi_voices;                /* voices per MIDI port */
         int synth_voices;               /* voices per SYNTH port */

         int read_use;                   /* R/O: subscribers for output (from     this port) */
         int write_use;                  /* R/O: subscribers for input (to th    is port) */

         void *kernel;                   /* reserved for kernel use (must be     NULL) */
         unsigned int flags;             /* misc. conditioning */
         unsigned char time_queue;       /* queue # for timestamping */
         char reserved[59];
};

#define SNDRV_SEQ_IOCTL_CREATE_PORT     _IOWR('S', 0x20, struct snd_seq_port_info)
#define SNDRV_SEQ_IOCTL_DELETE_PORT     _IOW ('S', 0x21, struct snd_seq_port_info)

typedef void* (*fun)(void*);

int client_id;
struct snd_seq_port_info info;
int fd;

void* thread1(void*);
void* thread2(void*);

int main(){

        fd=open("/dev/snd/seq",O_RDWR);
        if(fd<0){
                perror("open");
                return -1;
        }
        int pversion;
        if(ioctl(fd,SNDRV_SEQ_IOCTL_PVERSION,&pversion)<0){
                perror("PVERSION");
                return -1;
        }else
                printf("pversion is %d\r\n",pversion);

        if(ioctl(fd,SNDRV_SEQ_IOCTL_CLIENT_ID,&client_id)<0){
                perror("client_id");
                return -1;
        }
        else{
                printf("client_id is %d\r\n",client_id);
        }


        info.addr.client=client_id;
        info.addr.port=255;
        pthread_t tid1,tid2,tid3,tid[1000];

        if(pthread_create(&tid1,NULL,thread1,NULL)){
                perror("thread_create");
        }
        //      if(pthread_create(&tid2,NULL,thread2,NULL)!=0){
        //      perror("thread_del1");
        //}
        //if(pthread_create(&tid3,NULL,thread2,NULL)!=0){
        //      perror("thread_del2");
        //}

        for(int i=0;i<1000;i++)
                pthread_create(&tid[i],NULL,thread2,NULL);
        pthread_join(tid1,NULL);
        //pthread_join(tid2,NULL);
        //pthread_join(tid3,NULL);

        for(int i=0;i<1000;i++)
                pthread_join(tid[i],NULL);
        return 1;
}
void* thread1(void *arg){
        int i=0;
        while(255){
                i++;
                if(ioctl(fd,SNDRV_SEQ_IOCTL_CREATE_PORT,&info)<0){
                //perror("create");
                //sleep(10);
                //continue;
        }
        else{
                printf("Client number is %d,port is %d\r\n",info.addr.client,info.addr.port);
               //sleep(10);
                 }

        }
        pthread_exit(0);
        }

void* thread2(void *arg){
        while(1){
                if(ioctl(fd,SNDRV_SEQ_IOCTL_DELETE_PORT,&info)<0){
                        // perror("Delete");
                }
                else
                        printf("Delete success\r\n");
        }
        pthread_exit(0);
}
